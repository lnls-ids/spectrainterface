"""Spectra functions."""

import numpy as _np
import matplotlib.pyplot as _plt
from matplotlib import colors
from spectrainterface.accelerator import StorageRingParameters
import mathphys
from spectrainterface.tools import SourceFunctions
from spectrainterface.sources import Undulator
import json
from spectrainterface import spectra
import sys
import time
import os
import multiprocessing

# REPOS_PATH = os.path.abspath("./")
# REPOS_PATH = __file__
REPOS_PATH = os.path.dirname(os.path.abspath(__file__))

ECHARGE = mathphys.constants.elementary_charge
EMASS = mathphys.constants.electron_mass
LSPEED = mathphys.constants.light_speed
ECHARGE_MC = ECHARGE / (2 * _np.pi * EMASS * LSPEED)
PLANCK = mathphys.constants.reduced_planck_constant
VACUUM_PERMITTICITY = mathphys.constants.vacuum_permitticity
PI = _np.pi


class SpectraTools:
    """Class with general spectra tools."""

    @staticmethod
    def _run_solver(input_template, verbose=False):
        """Run spectra.

        Args:
            input_template (dict): Dictionary containing
            calculation parameters.
            verbose (bool): If true it will print elapsed time

        Returns:
            dict: Output data dictionary
        """
        input_str = json.dumps(input_template)

        # call solver with the input string (JSON format)
        solver = spectra.Solver(input_str)

        # check if the parameter load is OK
        isready = solver.IsReady()
        if isready is False:
            print("Parameter load failed.")
            sys.exit()

        t0 = time.time()
        # start calculation
        solver.Run()
        dt = time.time() - t0
        if verbose:
            print("elapsed time: {0:.1f} s".format(dt))
        return solver

    @staticmethod
    def _set_accelerator_config(accelerator, input_template, flag_bend):
        input_template["Accelerator"]["Energy (GeV)"] = accelerator.energy
        input_template["Accelerator"]["Current (mA)"] = accelerator.current

        input_template["Accelerator"]["&sigma;<sub>z</sub> (mm)"] = (
            accelerator.sigmaz
        )

        input_template["Accelerator"]["Nat. Emittance (m.rad)"] = (
            accelerator.nat_emittance
        )

        input_template["Accelerator"]["Coupling Constant"] = (
            accelerator.coupling_constant
        )

        input_template["Accelerator"]["Energy Spread"] = (
            accelerator.energy_spread
        )

        input_template["Accelerator"]["&beta;<sub>x,y</sub> (m)"] = [
            accelerator.betax,
            accelerator.betay,
        ]

        input_template["Accelerator"]["&alpha;<sub>x,y</sub>"] = [
            accelerator.alphax,
            accelerator.alphay,
        ]

        input_template["Accelerator"]["&eta;<sub>x,y</sub> (m)"] = [
            accelerator.etax,
            accelerator.etay,
        ]

        input_template["Accelerator"]["&eta;'<sub>x,y</sub>"] = [
            accelerator.etapx,
            accelerator.etapy,
        ]

        input_template["Accelerator"]["Options"]["Injection Condition"] = (
            accelerator.injection_condition
        )

        input_template["Accelerator"]["Options"]["Zero Emittance"] = (
            accelerator.zero_emittance
        )

        input_template["Accelerator"]["Options"]["Zero Energy Spread"] = (
            accelerator.zero_energy_spread
        )
        if flag_bend:
            input_template["Accelerator"]["Options"]["Injection Condition"] = (
                "Align at Center"
            )
        else:
            input_template["Accelerator"]["Options"]["Injection Condition"] = (
                "Align at Entrance"
            )

        return input_template


class GeneralConfigs(SourceFunctions):
    """Class with general configs."""

    class SourceType:
        """Sub class to define source type."""

        user_defined = "userdefined"
        horizontal_undulator = "linearundulator"
        vertical_undulator = "verticalundulator"
        helical_undulator = "helicalundulator"
        elliptic_undulator = "ellipticundulator"
        figure8_undulator = "figure8undulator"
        vertical_figure8_undulator = "verticalfigure8undulator"
        bending_magnet = "bendingmagnet"
        wiggler = "wiggler"

    def __init__(self):
        """Class constructor."""
        self._distance_from_source = 10  # [m]
        self._source_type = self.SourceType.user_defined
        self._field = None
        self._length = None
        self._bx_peak = None
        self._by_peak = None
        self._period = None
        self._kx = None
        self._ky = None
        self._rho = None

    @property
    def source_type(self):
        """Source type.

        Returns:
            CalcConfigs variables: Magnetic field, it can be defined by user or
            generated by spectra.
        """
        return self._source_type

    @property
    def field(self):
        """Magnetic field defined by user.

        Returns:
            numpy array: First column contains longitudinal spatial
            coordinate (z) [mm], second column contais vertical field
            [T], and third column constais horizontal field [T].
        """
        return self._field

    @property
    def length(self):
        """Length of device.

        Returns:
            float: Length [m]
        """
        return self._length

    @property
    def period(self):
        """Insertion device period [mm].

        Returns:
            float: ID's period [mm]
        """
        return self._period

    @property
    def by_peak(self):
        """Insertion device vertical peak field [T].

        Returns:
            float: by peak field [T]
        """
        return self._by_peak

    @property
    def bx_peak(self):
        """Insertion device horizontal peak field [T].

        Returns:
            float: bx peak field [T]
        """
        return self._bx_peak

    @property
    def ky(self):
        """Vertical deflection parameter (Ky).

        Returns:
            float: Vertical deflection parameter
        """
        return self._ky

    @property
    def kx(self):
        """Horizontal deflection parameter (Kx).

        Returns:
            float: Horizontal deflection parameter
        """
        return self._kx

    @property
    def rho(self):
        """Curvature radius.

        Returns:
            float: Curvature radius [m]
        """
        return self._rho

    @property
    def distance_from_source(self):
        """Distance from source.

        Returns:
            float: Distance from source [m]
        """
        return self._distance_from_source

    @source_type.setter
    def source_type(self, value):
        self._source_type = value

    @field.setter
    def field(self, value):
        if self.source_type != self.SourceType.user_defined:
            raise ValueError(
                "Field can only be defined if source type is user_defined."
            )
        else:
            self._field = value

    @length.setter
    def length(self, value):
        self._length = value

    @period.setter
    def period(self, value):
        if (
            self.source_type == self.SourceType.user_defined
            or self.source_type == self.SourceType.bending_magnet
        ):
            raise ValueError(
                "Period can only be defined if source type is not user_defined or is not a bending."  # noqa: E501
            )
        else:
            self._period = value
            if self._bx_peak is not None:
                self._kx = 1e-3 * ECHARGE_MC * self._bx_peak * self.period
            if self._by_peak is not None:
                self._ky = 1e-3 * ECHARGE_MC * self._by_peak * self.period
            if self._kx is not None:
                self._bx_peak = self._kx / (ECHARGE_MC * 1e-3 * self.period)
            if self._ky is not None:
                self._by_peak = self._ky / (ECHARGE_MC * 1e-3 * self.period)

    @by_peak.setter
    def by_peak(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "By peak can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.vertical_undulator:
            raise ValueError(
                "By peak can not be defined if source type is a vertical undulator."  # noqa: E501
            )
        else:
            self._by_peak = value
            if self.period is not None:
                self._ky = 1e-3 * ECHARGE_MC * self._by_peak * self.period
                if (
                    self.source_type
                    == self.SourceType.vertical_figure8_undulator
                ):
                    self._ky *= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._bx_peak = value
                if self.period is not None:
                    self._kx = self.ky

    @bx_peak.setter
    def bx_peak(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Bx peak can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.horizontal_undulator:
            raise ValueError(
                "Bx peak can not be defined if source type is a horizontal undulator."  # noqa: E501
            )
        else:
            self._bx_peak = value
            if self.period is not None:
                self._kx = 1e-3 * ECHARGE_MC * self._bx_peak * self.period
                if self.source_type == self.SourceType.figure8_undulator:
                    self._kx *= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._by_peak = value
                if self.period is not None:
                    self._ky = self.kx

    @ky.setter
    def ky(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Ky can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.vertical_undulator:
            raise ValueError(
                "Ky can not be defined if source type is a vertical undulator."
            )  # noqa: E501
        else:
            self._ky = value
            if self.period is not None:
                self._by_peak = self._ky / (ECHARGE_MC * 1e-3 * self.period)
                if (
                    self.source_type
                    == self.SourceType.vertical_figure8_undulator
                ):
                    self._by_peak /= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._kx = value
                if self.period is not None:
                    self._bx_peak = self.bx_peak

    @kx.setter
    def kx(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Kx can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.horizontal_undulator:
            raise ValueError(
                "Kx can not be defined if source type is a horizontal undulator."  # noqa: E501
            )
        else:
            self._kx = value
            if self.period is not None:
                self._bx_peak = self._kx / (ECHARGE_MC * 1e-3 * self.period)
                if self.source_type == self.SourceType.figure8_undulator:
                    self._bx_peak /= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._kx = value
                if self.period is not None:
                    self._bx_peak = self.bx_peak

    @rho.setter
    def rho(self, value):
        if self.source_type == self.SourceType.bending_magnet:
            self._rho = value
        else:
            raise ValueError(
                "Curvature radius can only be defined if source is a bending magnet."  # noqa: E501
            )

    @distance_from_source.setter
    def distance_from_source(self, value):
        self._distance_from_source = value


class Calc(GeneralConfigs, SpectraTools):
    """Class with methods to calculate flux."""

    class CalcConfigs:
        """Sub class to define calculation parameters."""

        class Method:
            """Sub class to define calculation method."""

            fixedpoint_near_field = "fpnearfield"
            fixedpoint_far_field = "fpfarfield"
            near_field = "nearfield"
            far_field = "farfield"
            fixedpoint_wigner = "fpwigner"
            wigner = "wigner"

        class Variable:
            """Sub class to define independet variable."""

            energy = "en"
            mesh_xy = "xy"
            k = "k"

        class Output:
            """Sub class to define output type."""

            flux_density = "fluxdensity"
            flux = "partialflux"
            brilliance = "brilliance"
            power_density = "powerdensity"
            power = "partialpower"

        class SlitShape:
            """Sub class to define slit shape."""

            none = ""
            circular = "circslit"
            rectangular = "retslit"

    def __init__(self, accelerator):
        """Class constructor."""
        super().__init__()
        self._method = self.CalcConfigs.Method.near_field
        self._indep_var = self.CalcConfigs.Variable.energy
        self._output_type = self.CalcConfigs.Output.flux_density
        self._slit_shape = self.CalcConfigs.SlitShape.none
        self._accelerator = accelerator
        self._input_template = None

        # Energy related
        self._target_harmonic = None
        self._energy_range = None
        self._energy_step = None
        self._slit_position = None
        self._slit_acceptance = None

        #  Mesh xy related
        self._target_energy = None
        self._x_range = None
        self._y_range = None
        self._x_nr_pts = None
        self._y_nr_pts = None

        #  K related
        self._harmonic_range = None
        self._k_range = None
        self._k_nr_pts = None
        self._slice_x = None
        self._slice_y = None
        self._slice_px = None
        self._slice_py = None

        #  Phase error
        self._add_phase_errors = False
        self._use_recovery_params = True

        # Output
        self._output_captions = None
        self._output_data = None
        self._output_variables = None

        self._flux = None
        self._power_density = None
        self._power = None
        self._brilliance = None
        self._pl = None
        self._pc = None
        self._pl45 = None
        self._energies = None
        self._x = None
        self._y = None
        self._k = None
        self._output_kx = None
        self._output_ky = None

    @property
    def method(self):
        """Method of calculation.

        Returns:
            CalcConfigs variables: Method of calculation, it can be near field
            or wigner functions, for example.
        """
        return self._method

    @property
    def indep_var(self):
        """Independent variable.

        Returns:
            CalcConfigs variables: Independet variable, it can be energy of a
            mesh in the xy plane
        """
        return self._indep_var

    @property
    def output_type(self):
        """Output type.

        Returns:
            CalcConfigs variables: Output type, it can be flux density or
            partial flux, for example.
        """
        return self._output_type

    @property
    def energy_range(self):
        """Energy range.

        Returns:
            List of ints: Energy range to calculate spectrum
             [initial point, final point].
        """
        return self._energy_range

    @property
    def energy_step(self):
        """Energy step.

        Returns:
            float: Spectrum energy step.
        """
        return self._energy_step

    @property
    def observation_angle(self):
        """Observation position [mrad].

        Returns:
            List of floats: Slit position [xpos, ypos] [mrad]
        """
        return self._slit_position

    @property
    def slit_acceptance(self):
        """Slit acceptance [mrad].

        Returns:
            List of floats: Slit acceptance [xpos, ypos] [mrad]
        """
        return self._slit_acceptance

    @property
    def slit_shape(self):
        """Slit shape.

        Returns:
            string: It can be circular or rectangular.
        """
        return self._slit_shape

    @property
    def target_energy(self):
        """Target energy.

        Returns:
            float: Target energy to analyse.
        """
        return self._target_energy

    @property
    def x_range(self):
        """Mesh x range.

        Returns:
            List of floats: x limits [mrad] [initial point, final point]
        """
        return self._x_range

    @property
    def y_range(self):
        """Mesh y range.

        Returns:
            List of floats: y limits [mrad] [initial point, final point]
        """
        return self._y_range

    @property
    def x_nr_pts(self):
        """Nr of x points.

        Returns:
            float: Number of horizontal mesh points
        """
        return self._x_nr_pts

    @property
    def y_nr_pts(self):
        """Nr of y points.

        Returns:
            float: Number of vertical mesh points
        """
        return self._y_nr_pts

    @property
    def harmonic_range(self):
        """Harmonic range.

        Returns:
            list of ints: List of harmonics to calculate brilliance.
        """
        return self._harmonic_range

    @property
    def target_harmonic(self):
        """Harmonic number.

        Returns:
            int: number of harmonic to calculate brilliance.
        """
        return self._target_harmonic

    @property
    def k_range(self):
        """K range.

        Returns:
            list of ints: List of k to calculate brilliance [kmin, kmax].
        """
        return self._k_range

    @property
    def k_nr_pts(self):
        """Number of k points.

        Returns:
            int: Number of K points.
        """
        return self._k_nr_pts

    @property
    def slice_x(self):
        """Slice x.

        Returns:
            float: Horizontal source point where Wigner function is
             calculated [mm].
        """
        return self._slice_x

    @property
    def slice_y(self):
        """Slice y.

        Returns:
            float: Vertical source point where Wigner function is
             calculated [mm].
        """
        return self._slice_y

    @property
    def slice_px(self):
        """Slice x'.

        Returns:
            float: Horizontal source angle where Wigner function is
             calculated [mrad].
        """
        return self._slice_px

    @property
    def slice_py(self):
        """Slice y'.

        Returns:
            float: Horizontal source angle where Wigner function is
             calculated [mrad].
        """
        return self._slice_py

    @property
    def output_captions(self):
        """Output captions.

        Returns:
            dict: Captions with spectra output
        """
        return self._output_captions

    @property
    def output_data(self):
        """Output data.

        Returns:
            dict: Data output from spectra
        """
        return self._output_data

    @property
    def output_variables(self):
        """Output variables.

        Returns:
            dict: Variables from spectra
        """
        return self._output_variables

    @property
    def flux(self):
        """Flux output.

        Returns:
            numpy array: Flux [ph/s/mr²/0.1%B.W].
        """
        return self._flux

    @property
    def power_density(self):
        """Power density output.

        Returns:
            numpy array: power density [kW/mr²].
        """
        return self._power_density

    @property
    def power(self):
        """Partial power output.

        Returns:
            numpy array: power density [kW].
        """
        return self._power

    @property
    def brilliance(self):
        """Brilliance output.

        Returns:
            numpy array: Brilliance [ph/s/mr²/0.1%B.W/mm²].
        """
        return self._brilliance

    @property
    def pl(self):
        """Linear polarization.

        Returns:
            numpy array: Linear polarization s1/s0
        """
        return self._pl

    @property
    def pc(self):
        """Circular polarization.

        Returns:
            numpy array: Circular polarization s3/s0
        """
        return self._pc

    @property
    def pl45(self):
        """Linear polarization 45°.

        Returns:
            numpy array: Linear polarization 45° s2/s0
        """
        return self._pl45

    @property
    def energies(self):
        """Energies.

        Returns:
            numpy array: Energyes [eV]
        """
        return self._energies

    @property
    def x(self):
        """Horizontal angle.

        Returns:
            numpy array: Horizontal angle [mrad]
        """
        return self._x

    @property
    def y(self):
        """Vertical angle.

        Returns:
            numpy array: Vertical angle [mrad]
        """
        return self._y

    @property
    def k(self):
        """Deflection parameter K.

        Returns:
            numpy array: Deflecetion parameter K.
        """
        return self._k

    @property
    def output_kx(self):
        """Deflection parameter Kx.

        Returns:
            numpy array: Deflecetion parameter Kx.
        """
        return self._kx

    @property
    def output_ky(self):
        """Deflection parameter Ky.

        Returns:
            numpy array: Deflecetion parameter Ky.
        """
        return self._ky

    @method.setter
    def method(self, value):
        self._method = value

    @indep_var.setter
    def indep_var(self, value):
        self._indep_var = value
        if value == self.CalcConfigs.Variable.energy:
            self._slit_position = [0, 0]
        elif value == self.CalcConfigs.Variable.mesh_xy:
            self._slit_position = None
            self._slit_shape = self.CalcConfigs.SlitShape.none

    @output_type.setter
    def output_type(self, value):
        self._output_type = value
        if value == self.CalcConfigs.Output.flux_density:
            self._slit_shape = self.CalcConfigs.SlitShape.none

    @energy_range.setter
    def energy_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Energy range can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._energy_range = value

    @energy_step.setter
    def energy_step(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Energy step can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._energy_step = value

    @observation_angle.setter
    def observation_angle(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Observation position can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._slit_position = value

    @slit_acceptance.setter
    def slit_acceptance(self, value):
        if self.output_type == self.CalcConfigs.Output.power:
            self._slit_acceptance = value
        elif self.output_type != self.CalcConfigs.Output.flux:
            if self.source_type == self.SourceType.bending_magnet:
                self._slit_acceptance = value
            else:
                raise ValueError(
                    "Slit acceptance can only be defined if the output type is flux."  # noqa: E501
                )
        else:
            self._slit_acceptance = value

    @slit_shape.setter
    def slit_shape(self, value):
        if (
            self.output_type == self.CalcConfigs.Output.flux
            or self.output_type == self.CalcConfigs.Output.power
        ):
            self._slit_shape = value
        else:
            raise ValueError(
                "Slit shape can only be defined if the output type is flux."  # noqa: E501
            )

    @target_energy.setter
    def target_energy(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            if self.indep_var == self.CalcConfigs.Variable.energy:
                if (
                    self.method
                    == self.CalcConfigs.Method.fixedpoint_near_field
                ):
                    self._target_energy = value
                elif (
                    self.method == self.CalcConfigs.Method.fixedpoint_far_field
                ):
                    self._target_energy = value
                else:
                    raise ValueError(
                        "Target energy can only be defined if the variable is a xy mesh or calculation method is a fixed point."  # noqa: E501
                    )
            else:
                raise ValueError(
                    "Target energy can only be defined if the variable is a xy mesh or calculation method is a fixed point."  # noqa: E501
                )
        else:
            self._target_energy = value

    @x_range.setter
    def x_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "X range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._x_range = value

    @y_range.setter
    def y_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Y range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._y_range = value

    @x_nr_pts.setter
    def x_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "X range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._x_nr_pts = value

    @y_nr_pts.setter
    def y_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Y range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._y_nr_pts = value

    @harmonic_range.setter
    def harmonic_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Harmonic range can only be defined if the variable is k."
            )
        else:
            self._harmonic_range = value

    @target_harmonic.setter
    def target_harmonic(self, value):
        if self.indep_var == self.CalcConfigs.Variable.energy:
            if self.method == self.CalcConfigs.Method.fixedpoint_wigner:
                self._target_harmonic = value
            else:
                raise ValueError(
                    "Harmonic number can only be defined if the method is fixed point wigner."  # noqa: E501
                )
        else:
            raise ValueError(
                "Harmonic number can only be defined if the variable is energy."  # noqa: E501
            )

    @k_range.setter
    def k_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "K range can only be defined if the variable is k."
            )
        else:
            self._k_range = value

    @k_nr_pts.setter
    def k_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "K nr points can only be defined if the variable is k."
            )
        else:
            self._k_nr_pts = value

    @slice_x.setter
    def slice_x(self, value):
        if self.indep_var == self.CalcConfigs.Variable.k:
            self._slice_x = value
        elif self.indep_var == self.CalcConfigs.Variable.energy:
            if self.method == self.CalcConfigs.Method.fixedpoint_wigner:
                self._slice_x = value
            else:
                raise ValueError(
                    "Slice x can only be defined if the method is fixed point wigner."  # noqa: E501
                )
        else:
            raise ValueError(
                "Slice x can only be defined if the variable is k  or energy."
            )

    @slice_y.setter
    def slice_y(self, value):
        if self.indep_var == self.CalcConfigs.Variable.k:
            self._slice_y = value
        elif self.indep_var == self.CalcConfigs.Variable.energy:
            if self.method == self.CalcConfigs.Method.fixedpoint_wigner:
                self._slice_y = value
            else:
                raise ValueError(
                    "Slice y can only be defined if the method is fixed point wigner."  # noqa: E501
                )
        else:
            raise ValueError(
                "Slice y can only be defined if the variable is k  or energy."
            )

    @slice_px.setter
    def slice_px(self, value):
        if self.indep_var == self.CalcConfigs.Variable.k:
            self._slice_px = value
        elif self.indep_var == self.CalcConfigs.Variable.energy:
            if self.method == self.CalcConfigs.Method.fixedpoint_wigner:
                self._slice_px = value
            else:
                raise ValueError(
                    "Slice x' can only be defined if the method is fixed point wigner."  # noqa: E501
                )
        else:
            raise ValueError(
                "Slice x' can only be defined if the variable is k  or energy."
            )

    @slice_py.setter
    def slice_py(self, value):
        if self.indep_var == self.CalcConfigs.Variable.k:
            self._slice_py = value
        elif self.indep_var == self.CalcConfigs.Variable.energy:
            if self.method == self.CalcConfigs.Method.fixedpoint_wigner:
                self._slice_py = value
            else:
                raise ValueError(
                    "Slice y' can only be defined if the method is fixed point wigner."  # noqa: E501
                )
        else:
            raise ValueError(
                "Slice y' can only be defined if the variable is k or energy."
            )

    def set_config(self):  # noqa: C901
        """Set calc config."""
        config_name = REPOS_PATH + "/calculation_parameters/"
        config_name += self.source_type
        config_name += "_"
        config_name += self.method
        config_name += "_"
        config_name += self.indep_var
        config_name += "_"
        config_name += self.output_type

        if self.slit_shape != "":
            config_name += "_"
            config_name += self.slit_shape

        config_name += ".json"

        file = open(config_name)
        input_temp = json.load(file)

        flag_bend = False

        input_temp = self._set_accelerator_config(
            self._accelerator, input_temp, flag_bend
        )

        if self.source_type == self.SourceType.bending_magnet:
            del input_temp["Accelerator"]["Options"]["Zero Energy Spread"]
            del input_temp["Accelerator"]["Options"]["Injection Condition"]
            flag_bend = True

        if self.field is not None:
            data = _np.zeros((3, len(self.field[:, 0])))
            data[0, :] = self.field[:, 0]
            data[1, :] = self.field[:, 2]
            data[2, :] = self.field[:, 1]
            input_temp["Light Source"]["Field Profile"]["data"] = data.tolist()

        if self.ky is not None:
            if (
                self.source_type == self.SourceType.horizontal_undulator
                or self.source_type == self.SourceType.helical_undulator
                or self.source_type == self.SourceType.wiggler
            ):
                input_temp["Light Source"]["K value"] = self.ky

        if self.kx is not None:
            if self.source_type == self.SourceType.vertical_undulator:
                input_temp["Light Source"]["K value"] = self.kx

        if self.kx is not None and self.ky is not None:
            if (
                self.source_type == self.SourceType.elliptic_undulator
                or self.source_type == self.SourceType.figure8_undulator
                or self.source_type
                == self.SourceType.vertical_figure8_undulator
            ):
                input_temp["Light Source"]["K<sub>x,y</sub>"] = [
                    self.kx,
                    self.ky,
                ]

        if self.by_peak is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["B (T)"] = self.by_peak
                energy = self._accelerator.energy
                brho = energy * 1e9 * ECHARGE / (ECHARGE * LSPEED)
                rho = brho / self.by_peak
                input_temp["Light Source"]["&rho; (m)"] = rho

            elif self.source_type == self.SourceType.wiggler:
                input_temp["Light Source"]["B (T)"] = self.by_peak

        if self.rho is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["&rho; (m)"] = self.rho
                energy = self._accelerator.energy
                brho = energy * 1e9 * ECHARGE / (ECHARGE * LSPEED)
                by = brho / self.rho
                input_temp["Light Source"]["B (T)"] = by

        if self.period is not None:
            input_temp["Light Source"]["&lambda;<sub>u</sub> (mm)"] = (
                self.period
            )

        if self.length is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["BM Length (m)"] = self.length
            else:
                input_temp["Light Source"]["Device Length (m)"] = self.length

        if self.energy_range is not None:
            input_temp["Configurations"]["Energy Range (eV)"] = (
                self.energy_range
            )

        if self.energy_step is not None:
            if (
                self.source_type == self.SourceType.bending_magnet
                or self.source_type == self.SourceType.wiggler
            ):
                nr_points = int(
                    (self.energy_range[1] - self.energy_range[0])
                    / self.energy_step
                )
                input_temp["Configurations"]["Points (Energy)"] = nr_points
            else:
                input_temp["Configurations"]["Energy Pitch (eV)"] = (
                    self.energy_step
                )

        if self.observation_angle is not None:
            if self.output_type == self.CalcConfigs.Output.flux_density:
                input_temp["Configurations"][
                    "Angle &theta;<sub>x,y</sub> (mrad)"
                ] = self.observation_angle
            elif self.output_type == self.CalcConfigs.Output.flux:
                input_temp["Configurations"][
                    "Slit Pos.: &theta;<sub>x,y</sub> (mrad)"
                ] = self.observation_angle

        if self.slit_acceptance is not None:
            if self.slit_shape == self.CalcConfigs.SlitShape.circular:
                input_temp["Configurations"][
                    "Slit &theta;<sub>1,2</sub> (mrad)"
                ] = self.slit_acceptance
            elif self.slit_shape == self.CalcConfigs.SlitShape.rectangular:
                input_temp["Configurations"][
                    "&Delta;&theta;<sub>x,y</sub> (mrad)"
                ] = self.slit_acceptance
            if self.source_type == self.SourceType.bending_magnet:
                if self.output_type == self.CalcConfigs.Output.flux_density:
                    input_temp["Configurations"]["X' Acceptance (mrad)"] = (
                        self.slit_acceptance
                    )

        if self.target_energy is not None:
            input_temp["Configurations"]["Target Energy (eV)"] = (
                self.target_energy
            )

        if self.target_harmonic is not None:
            input_temp["Configurations"]["Target Harmonic"] = (
                self.target_harmonic
            )

        if self.x_range is not None:
            input_temp["Configurations"][
                "&theta;<sub>x</sub> Range (mrad)"
            ] = self.x_range
            input_temp["Configurations"][
                "&theta;<sub>y</sub> Range (mrad)"
            ] = self.y_range
            input_temp["Configurations"]["Points (x)"] = self.x_nr_pts
            input_temp["Configurations"]["Points (y)"] = self.y_nr_pts

        if self.harmonic_range is not None:
            input_temp["Configurations"]["Harmonic Range"] = (
                self.harmonic_range
            )
            if (
                self.source_type == self.SourceType.horizontal_undulator
                or self.source_type == self.SourceType.vertical_undulator
                or self.source_type == self.SourceType.helical_undulator
            ):
                input_temp["Configurations"]["K Range"] = self.k_range
            else:
                input_temp["Configurations"]["K<sub>&perp;</sub> Range"] = (
                    self.k_range
                )
            if self.method == self.CalcConfigs.Method.wigner:
                input_temp["Configurations"]["Slice X (mm)"] = self.slice_x
                input_temp["Configurations"]["Slice Y (mm)"] = self.slice_y
                input_temp["Configurations"]["Slice X' (mrad)"] = self.slice_px
                input_temp["Configurations"]["Slice Y' (mrad)"] = self.slice_py
            input_temp["Configurations"]["Points (K)"] = self.k_nr_pts

        input_temp["Configurations"]["Distance from the Source (m)"] = (
            self.distance_from_source
        )

        self._input_template = input_temp

    def verify_valid_parameters(self):  # noqa: C901
        """Check if calculation parameters are valid.

        Returns:
            bool: Returns True of False.
        """
        if self.indep_var == self.CalcConfigs.Variable.energy:
            if self.target_energy is None:
                if self.energy_range is None:
                    if self.target_harmonic is None:
                        raise ValueError("Energy range must be defined.")

            if self.target_energy is None:
                if self.energy_step is None:
                    if self.target_harmonic is None:
                        raise ValueError("Energy step must be defined.")

            if self.observation_angle is None:
                raise ValueError("Observation angle must be defined.")

            if self.source_type == self.SourceType.bending_magnet:
                if self.slit_acceptance is None:
                    raise ValueError("Slit acceptance must be defined.")

            if self.output_type == self.CalcConfigs.Output.flux:
                if self.slit_acceptance is None:
                    raise ValueError("Slit acceptance must be defined.")

                if self.slit_shape is None:
                    raise ValueError("Slit shape must be defined.")

        if self.indep_var == self.CalcConfigs.Variable.mesh_xy:
            if (
                self.target_energy is None
                and self.output_type == self.CalcConfigs.Output.flux_density
            ):
                raise ValueError("Energy target must be defined")

            if self.x_range is None:
                raise ValueError("X range must be defined.")

            if self.y_range is None:
                raise ValueError("Y range must be defined.")

            if self.x_nr_pts is None:
                raise ValueError("Nr. of x points must be defined.")

            if self.y_nr_pts is None:
                raise ValueError("Nr. of y points must be defined.")

        if self.indep_var == self.CalcConfigs.Variable.k:
            if self.harmonic_range is None:
                raise ValueError("Harmonic range must be defined.")

            if self.k_range is None:
                raise ValueError("K range must be defined.")

            if self.k_nr_pts is None:
                raise ValueError("Number of K points must be defined.")

            if self.method == self.CalcConfigs.Method.wigner:
                if self.slice_x is None:
                    raise ValueError("Slice x must be defined.")

                if self.slice_y is None:
                    raise ValueError("Slice y must be defined.")

                if self.slice_px is None:
                    raise ValueError("Slice px must be defined.")

                if self.slice_py is None:
                    raise ValueError("Slice py must be defined.")

        return True

    def run_calculation(self, time_print: bool = False):
        """Run calculation."""
        self.verify_valid_parameters()
        solver = self._run_solver(self._input_template, time_print)
        self._solver = solver
        captions, data, variables = self.extractdata(solver)
        self._output_captions = captions
        self._output_data = data
        self._output_variables = variables
        self._set_outputs()

    def _set_outputs(self):  # noqa: C901
        data = self._output_data
        captions = self._output_captions
        variables = self._output_variables

        if self.indep_var == self.CalcConfigs.Variable.energy:
            if (
                self.method == self.CalcConfigs.Method.fixedpoint_near_field
                or self.method == self.CalcConfigs.Method.fixedpoint_far_field
            ):
                if self.output_type == self.CalcConfigs.Output.power:
                    self._power = data[0][0]
                else:
                    self._flux = data[0]
                    self._pl = data[1]
                    self._pc = data[2]
                    self._pl45 = data[3]
            elif self.method == self.CalcConfigs.Method.fixedpoint_wigner:
                self._brilliance = data[0]
            else:
                self._flux = data[0, :]
                if len(captions["titles"]) == 5:
                    self._pl = data[1, :]
                    self._pc = data[2, :]
                    self._pl45 = data[3, :]
                elif len(captions["titles"]) == 6:
                    self._brilliance = data[1, :]
                    self._pl = data[2, :]
                    self._pc = data[3, :]
                    self._pl45 = data[4, :]
                self._energies = self._output_variables[0, :]

        elif self.indep_var == self.CalcConfigs.Variable.mesh_xy:
            if self.output_type == self.CalcConfigs.Output.power_density:
                self._power_density = data[0, :]
                self._x = _np.array(self._output_variables[0][:])
                self._y = _np.array(self._output_variables[1][:])
                self._power_density = _np.reshape(
                    self._power_density, (len(self._x), len(self._y))
                )
                self._power_density = _np.flip(self._power_density, axis=0)

            if self.output_type == self.CalcConfigs.Output.flux_density:
                self._flux = data[0, :]
                self._x = _np.array(self._output_variables[0][:])
                self._y = _np.array(self._output_variables[1][:])
                self._flux = _np.reshape(
                    self._flux, (len(self._x), len(self._y))
                )
                self._flux = _np.flip(self._flux, axis=0)
                self._pl = data[1, :]
                self._pc = data[2, :]
                self._pl45 = data[3, :]

                self._pl = _np.reshape(self._pl, (len(self._x), len(self._y)))
                self._pl = _np.flip(self._pl, axis=0)

                self._pc = _np.reshape(self._pc, (len(self._x), len(self._y)))
                self._pc = _np.flip(self._pc, axis=0)

                self._pl45 = _np.reshape(
                    self._pl45, (len(self._x), len(self._y))
                )
                self._pl45 = _np.flip(self._pl45, axis=0)

        elif self.indep_var == self.CalcConfigs.Variable.k:
            if self.method == self.CalcConfigs.Method.wigner:
                if (
                    self.source_type != self.SourceType.elliptic_undulator
                    and self.source_type != self.SourceType.figure8_undulator
                    and self.source_type
                    != self.SourceType.vertical_figure8_undulator
                ):
                    self._k = data[:, 0, :]
                    self._brilliance = data[:, 1, :]
                    self._energies = variables[:, :]
                    if self._add_phase_errors is True:
                        self._brilliance = self.apply_phase_errors(
                            self._brilliance, self._use_recovery_params
                        )

                else:
                    self._kx = data[:, 0, :]
                    self._ky = data[:, 1, :]
                    self._brilliance = data[:, 2, :]
                    self._energies = variables[:, :]
            elif self.method == self.CalcConfigs.Method.far_field:
                if (
                    self.source_type != self.SourceType.elliptic_undulator
                    and self.source_type != self.SourceType.figure8_undulator
                    and self.source_type
                    != self.SourceType.vertical_figure8_undulator
                ):
                    self._k = data[:, 1, :]
                    self._flux = data[:, 2, :]
                    self._energies = variables[:, :]
                    if self._add_phase_errors is True:
                        self._flux = self.apply_phase_errors(
                            self._flux, self._use_recovery_params
                        )
                else:
                    self._kx = data[:, 1, :]
                    self._ky = data[:, 2, :]
                    self._flux = data[:, 3, :]
                    self._energies = variables[:, :]

    def extractdata(self, solver):
        """Extract solver data.

        Args:
            solver (spectra solver): Spectra solver object

        Returns:
            dict: captions
            dict: data
            dict: variables
        """
        captions = solver.GetCaptions()
        data = _np.array(solver.GetData()["data"])
        if self.indep_var != self.CalcConfigs.Variable.k:
            variables = _np.array(solver.GetData()["variables"], dtype=object)
        else:
            if (
                self.source_type == self.SourceType.figure8_undulator
                or self.source_type
                == self.SourceType.vertical_figure8_undulator
            ):
                nr_harmonics = (
                    int((self.harmonic_range[-1] - self.harmonic_range[0]) * 2)
                    + 1
                )
                if self.method == self.CalcConfigs.Method.wigner:
                    data = _np.zeros((nr_harmonics, 3, self.k_nr_pts))
                else:
                    data = _np.zeros((nr_harmonics, 7, self.k_nr_pts))
            else:
                nr_harmonics = (
                    int((self.harmonic_range[-1] - self.harmonic_range[0]) / 2)
                    + 1
                )
                if self.source_type == self.SourceType.elliptic_undulator:
                    if self.method == self.CalcConfigs.Method.wigner:
                        data = _np.zeros((nr_harmonics, 3, self.k_nr_pts))
                    else:
                        data = _np.zeros((nr_harmonics, 7, self.k_nr_pts))
                else:
                    if self.method == self.CalcConfigs.Method.wigner:
                        data = _np.zeros((nr_harmonics, 2, self.k_nr_pts))
                    else:
                        data = _np.zeros((nr_harmonics, 6, self.k_nr_pts))
            variables = _np.zeros((nr_harmonics, self.k_nr_pts))
            for i in range(nr_harmonics):
                variables[i, :] = _np.array(
                    solver.GetDetailData(i)["variables"]
                )
                data[i, :, :] = _np.array(solver.GetDetailData(i)["data"])
        return captions, data, variables

    def apply_phase_errors(self, values, rec_param=True):
        """Add phase errors.

        Args:
            values (numpy 2d array): It can be brilliance of flux
            rec_param (bool, optional): Use recovery params. Defaults to True.

        Returns:
            numpy 2d array: brilliance of flux with phase errors
        """
        fname = REPOS_PATH + "/files/phase_errors_fit.txt"
        data = _np.genfromtxt(fname, unpack=True, skip_header=1)
        # h = data[:, 0]
        ph_err1 = data[:, 1]
        ph_err2 = data[:, 2]
        harm0 = self.harmonic_range[0]
        harmf = self.harmonic_range[-1]
        idcs = (_np.arange(harm0 - 1, harmf, 2),)
        if rec_param:
            ph = ph_err2[idcs]
        else:
            ph = ph_err1[idcs]
        ph_full = _np.tile(ph, values.shape[1]).reshape(
            values.shape, order="F"
        )
        return values * ph_full

    @staticmethod
    def process_brilliance_curve(
        input_energies, input_brilliance, superp_value=250
    ):
        """Process brilliance curve.

        Args:
            input_energies (numpy 2d array): Array with energies and
             brilliances for each harmonic
            input_brilliance (numpy 2d array): Array with energies and
                brilliances for each harmonic
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.

        Returns:
            _type_: _description_
        """
        flag_pre_processing = False
        harm_nr = input_energies.shape[0]
        energies = _np.zeros((harm_nr, 2001))
        brilliance = _np.zeros((harm_nr, 2001))
        for i in _np.arange(harm_nr - 1):
            if flag_pre_processing is False:
                e_harm = input_energies[i, :]
                b_harm = input_brilliance[i, :]
                idx = _np.argsort(e_harm)
                e_harm = e_harm[idx]
                b_harm = b_harm[idx]
                e_harm_interp = _np.linspace(
                    _np.min(e_harm), _np.max(e_harm), 2001
                )
                b_harm_interp = _np.exp(
                    _np.interp(e_harm_interp, e_harm, _np.log(b_harm))
                )
            else:
                e_harm_interp = energies[i, :]
                b_harm_interp = brilliance[i, :]

            e_next_harm = input_energies[i + 1, :]
            b_next_harm = input_brilliance[i + 1, :]
            idx = _np.argsort(e_next_harm)
            e_next_harm = e_next_harm[idx]
            b_next_harm = b_next_harm[idx]

            e_next_harm_interp = _np.linspace(
                _np.min(e_next_harm), _np.max(e_next_harm), 2001
            )
            b_next_harm_interp = _np.exp(
                _np.interp(
                    e_next_harm_interp, e_next_harm, _np.log(b_next_harm)
                )
            )

            max_e_harm = _np.nanmax(e_harm_interp)
            min_e_harm = _np.nanmin(e_harm_interp)
            max_e_next_harm = _np.nanmax(e_next_harm_interp)
            min_e_next_harm = _np.nanmin(e_next_harm_interp)

            flag_pre_processing = False
            if max_e_harm >= min_e_next_harm:
                flag_pre_processing = True

                min_abs = _np.max((min_e_harm, min_e_next_harm))
                max_abs = _np.min((max_e_harm, max_e_next_harm))
                energy_intersect = _np.linspace(min_abs, max_abs, 2001)

                b_harm_intersect = _np.interp(
                    energy_intersect, e_harm_interp, b_harm_interp
                )
                b_next_harm_intersect = _np.interp(
                    energy_intersect, e_next_harm_interp, b_next_harm_interp
                )

                idcs_bigger = _np.where(
                    b_next_harm_intersect >= b_harm_intersect
                )

                ecross = energy_intersect[_np.min(idcs_bigger)]

                idx_cut_e1 = _np.nanargmin(
                    _np.abs(e_harm_interp - ecross - superp_value)
                )
                idx_cut_e3 = _np.nanargmin(
                    _np.abs(e_next_harm_interp - ecross + superp_value)
                )

                e_harm = e_harm_interp[:idx_cut_e1]
                b_harm = b_harm_interp[:idx_cut_e1]

                e_next_harm = e_next_harm_interp[idx_cut_e3:]
                b_next_harm = b_next_harm_interp[idx_cut_e3:]

            e_harm_new = _np.copy(e_harm)
            b_harm_new = _np.copy(b_harm)
            e_harm_new.resize(2001)
            b_harm_new.resize(2001)
            idx = len(e_harm) - 1
            e_harm_new[idx:] = _np.full(len(e_harm_new[idx:]), _np.nan)
            b_harm_new[idx:] = _np.full(len(e_harm_new[idx:]), _np.nan)

            e_next_harm_new = _np.copy(e_next_harm)
            b_next_harm_new = _np.copy(b_next_harm)
            e_next_harm_new.resize(2001)
            b_next_harm_new.resize(2001)
            idx = len(e_next_harm) - 1
            e_next_harm_new[idx:] = _np.full(
                len(e_next_harm_new[idx:]), _np.nan
            )
            b_next_harm_new[idx:] = _np.full(
                len(e_next_harm_new[idx:]), _np.nan
            )

            energies[i, :] = e_harm_new
            brilliance[i, :] = b_harm_new

            energies[i + 1, :] = e_next_harm_new
            brilliance[i + 1, :] = b_next_harm_new

        return energies, brilliance


class SpectraInterface:
    """Spectra Interface class."""

    def __init__(self):
        """Class constructor."""
        self._accelerator = StorageRingParameters()
        self._calc = Calc(self._accelerator)
        self._sources = None
        self._energies = None
        self._brilliances = None
        self._fluxes = None
        self._target_energy = None
        self._flux_density_matrix = None
        self._info_matrix_flux_density = None
        self._flux_matrix = None
        self._info_matrix_flux = None
        self._brilliance_matrix = None
        self._info_matrix_brilliance = None
        self._flag_brill_processed = False
        self._flag_flux_processed = False

    @property
    def accelerator(self):
        """Accelerator parameters.

        Returns:
            StorageRingParameters object: class to config accelerator.
        """
        return self._accelerator

    @property
    def calc(self):
        """CalcFlux object.

        Returns:
            CalcFlux object: Class to calculate flux
        """
        return self._calc

    @property
    def sources(self):
        """Sources list.

        Returns:
            List: List of sources objects
        """
        return self._sources

    @property
    def energies(self):
        """List of energies for each undulator.

        Returns:
            list of numpy arrays: Energies for each undulator, for each
             harmonic.
        """
        return self._energies

    @property
    def brilliances(self):
        """List of brilliances for each undulator.

        Returns:
            list of numpy arrays: Brilliances for each undulator, for each
             harmonic.
        """
        return self._brilliances

    @property
    def fluxes(self):
        """List of fluxes for each undulator.

        Returns:
            list of numpy arrays: Fluxes for each undulator, for each
             harmonic.
        """
        return self._fluxes

    @property
    def target_energy(self):
        """Target energy.

        Returns:
            float: Target energy to analyse.
        """
        return self._target_energy

    @property
    def flux_density_matrix(self):
        """Flux density matrix.

        Returns:
            Array: Flux density matrix to analyse.
        """
        return self._flux_density_matrix

    @property
    def flux_matrix(self):
        """Flux matrix.

        Returns:
            Array: Flux matrix to analyse.
        """
        return self._flux_matrix

    @property
    def brilliance_matrix(self):
        """Brilliance matrix.

        Returns:
            Array: brilliance matrix to analyse.
        """
        return self._brilliance_matrix

    @property
    def info_matrix_flux_density(self):
        """Information about the respective undulators in
                the flux density matrix.

        Returns:
            Array: Undulators information to analyse.
        """
        return self._info_matrix_flux_density

    @property
    def info_matrix_flux(self):
        """Information about the respective undulators in the flux matrix.

        Returns:
            Array: Undulators information to analyse.
        """
        return self._info_matrix_flux

    @property
    def info_matrix_brilliance(self):
        """Information about the respective undulators in the brilliance matrix.

        Returns:
            Array: Undulators information to analyse.
        """
        return self._info_matrix_brilliance

    @sources.setter
    def sources(self, value):
        self._sources = value

    @target_energy.setter
    def target_energy(self, value):
        self._target_energy = value

    def apply_phase_error_matrix(self, values, harm, rec_param=True):
        """Add phase errors.

        Args:
            values (numpy 2d array): It can be brilliance of flux
            rec_param (bool, optional): Use recovery params. Defaults to True.

        Returns:
            numpy 2d array: brilliance of flux with phase errors
        """
        fname = REPOS_PATH + "/files/phase_errors_fit.txt"
        data = _np.genfromtxt(fname, unpack=True, skip_header=1)
        h = data[:, 0]
        ph_err1 = data[:, 1]
        ph_err2 = data[:, 2]
        idx = _np.argmin(_np.abs(harm - h))
        if rec_param:
            ph = ph_err2[idx]
        else:
            ph = ph_err1[idx]
        return values * ph

    def calc_brilliance_curve(  # noqa: C901
        self,
        harmonic_range=[1, 5],
        nr_pts_k=15,
        kmin=0.2,
        emax=20e3,
        x_accep=1,
        beta_sections=None,
    ):
        """Calc brilliance curve.

        Args:
            harmonic_range (list, optional): List of desired harmonics.
             Defaults to [1, 5].
            nr_pts_k (int, optional): Number of k points. Defaults to 15.
            kmin (float): Minimum k value. Defaults to 0.2
            emax (float): Max value of energy for dipoles and wigglers.
            x_accep (float): X acceptance for bending magnet radiation.
            beta_sections (list of string): List of beta sections for each
             source.

        """
        self._flag_brill_processed = False
        self.calc._slit_shape = ""
        source_list = self.sources
        energies = list()
        brilliances = list()
        flag_bend = False
        for i, source in enumerate(source_list):
            print(
                "Calculating curve for source {:.0f}/{:.0f}".format(
                    i + 1, len(source_list)
                )
            )
            if source.source_type != "bendingmagnet":
                if source.gap == 0:
                    kmax = source.calc_max_k(self.accelerator)
                else:
                    kmax = source.get_k()

                if source.source_type == "wiggler":
                    flag_bend = True
                    b_max = source.undulator_k_to_b(kmax, source.period)
                    self.calc.source_type = self.calc.SourceType.wiggler
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                    self.calc.output_type = (
                        self.calc.CalcConfigs.Output.flux_density
                    )
                    self.calc.period = source.period
                    self.calc.by_peak = b_max
                    self.calc.ky = kmax
                    self.calc.observation_angle = [0, 0]
                    self.calc.energy_range = [1, emax]
                    self.calc.energy_step = 50
                else:
                    self.calc.output_type = (
                        self.calc.CalcConfigs.Output.brilliance
                    )
                    self.calc._add_phase_errors = source.add_phase_errors
                    self.calc._use_recovery_params = source.use_recovery_params
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.k
                    self.calc.method = self.calc.CalcConfigs.Method.wigner
                    self.calc.slice_x = 0
                    self.calc.slice_px = 0
                    self.calc.slice_y = 0
                    self.calc.slice_py = 0
                    self.calc.harmonic_range = harmonic_range
                    self.calc.k_nr_pts = nr_pts_k

                    polarization = source.polarization
                    if polarization == "hp":
                        self.calc.source_type = (
                            self.calc.SourceType.horizontal_undulator
                        )
                        self.calc.by_peak = 1
                    elif polarization == "vp":
                        self.calc.source_type = (
                            self.calc.SourceType.vertical_undulator
                        )
                        self.calc.bx_peak = 1
                    elif polarization == "cp":
                        self.calc.source_type = (
                            self.calc.SourceType.elliptic_undulator
                        )
                        self.calc.bx_peak = 1
                        self.calc.by_peak = source.fields_ratio
                    else:
                        return

                    self.calc.k_range = [kmin, kmax]
                    self.calc.period = source.period

            else:
                flag_bend = True
                b = source.b_peak
                self.calc.source_type = self.calc.SourceType.bending_magnet
                self.calc.method = self.calc.CalcConfigs.Method.far_field
                self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                self.calc.slit_acceptance = x_accep
                self.calc.output_type = (
                    self.calc.CalcConfigs.Output.flux_density
                )
                self.calc.by_peak = b
                self.calc.observation_angle = [0, 0]
                self.calc.energy_range = [1, emax]
                self.calc.energy_step = 50

            self.calc.length = source.source_length

            if beta_sections is not None:
                if beta_sections[i] == "high":
                    self.accelerator.set_high_beta_section()
                elif beta_sections[i] == "low":
                    self.accelerator.set_low_beta_section()
                elif beta_sections[i] == "b2":
                    self.accelerator.set_b2_section()
                elif beta_sections[i] == "bc":
                    self.accelerator.set_bc_section()
                elif beta_sections[i] == "b1":
                    self.accelerator.set_b1_section()
                else:
                    raise ValueError("Invalid beta section.")

            self.calc.set_config()
            self.calc.run_calculation()

            energies.append(self.calc.energies)
            brilliances.append(self.calc.brilliance)

        if flag_bend:
            energies = _np.array(energies, dtype=object)
            brilliances = _np.array(brilliances, dtype=object)
        else:
            energies = _np.array(energies)
            brilliances = _np.array(brilliances)
        self._energies = energies
        self._brilliances = brilliances

    def calc_flux_curve(  # noqa: C901
        self,
        energy_range=[1, 5],
        harmonic_range=[1, 5],
        nr_pts_k=15,
        kmin=0.2,
        slit_shape="circslit",
        slit_acceptances=[[0, 0.04]],
        beta_sections=None,
    ):
        """Calc flux curves.

        Args:
            energy_range (list, optional): Energy range for wigglers and
             bending magnets. Defaults to [1, 5].
            harmonic_range (list, optional): List of desired harmonics.
             Defaults to [1, 5].
            nr_pts_k (int, optional): Number of k points. Defaults to 15.
            kmin (float): Minimum k value. Defaults to 0.2
            slit_shape (str, optional): Circular or rectangular.
             Defaults to "circslit".
            slit_acceptances (list, optional): Slit acceptance.
             Defaults to [0, 0.04].
            beta_sections (list of string): List of beta sections for each
             source.

        Raises:
            ValueError: _description_
        """
        self._flag_flux_processed = False
        source_list = self.sources
        energies = list()
        fluxes = list()
        slit_acceptances = _np.array(slit_acceptances)
        if slit_acceptances.shape[0] == 1:
            slit_acceptances = _np.full(
                (len(source_list), 2), slit_acceptances[0]
            )
        slit_acceptances = slit_acceptances.tolist()
        flag_bend = False
        for i, source in enumerate(source_list):
            print(
                "Calculating curve for source {:.0f}/{:.0f}".format(
                    i + 1, len(source_list)
                )
            )
            if source.source_type != "bendingmagnet":
                if source.gap == 0:
                    kmax = source.calc_max_k(self.accelerator)
                else:
                    kmax = source.get_k()
                if source.source_type == "wiggler":
                    flag_bend = True
                    b_max = source.undulator_k_to_b(kmax, source.period)
                    self.calc.source_type = self.calc.SourceType.wiggler
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                    self.calc.output_type = self.calc.CalcConfigs.Output.flux
                    self.calc.slit_shape = slit_shape
                    self.calc.period = source.period
                    self.calc.by_peak = b_max
                    self.calc.ky = kmax
                    self.calc.observation_angle = [0, 0]
                    self.calc.slit_acceptance = slit_acceptances[i]
                    self.calc.energy_range = energy_range
                    self.calc.energy_step = 1
                else:
                    self.calc._add_phase_errors = source.add_phase_errors
                    self.calc._use_recovery_params = source.use_recovery_params
                    self.calc.output_type = self.calc.CalcConfigs.Output.flux
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.k
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.slit_shape = slit_shape
                    self.calc.harmonic_range = harmonic_range
                    self.calc.k_nr_pts = nr_pts_k
                    self.calc.slit_acceptance = slit_acceptances[i]

                    polarization = source.polarization
                    if polarization == "hp":
                        self.calc.source_type = (
                            self.calc.SourceType.horizontal_undulator
                        )
                        self.calc.by_peak = 1
                    elif polarization == "vp":
                        self.calc.source_type = (
                            self.calc.SourceType.vertical_undulator
                        )
                        self.calc.bx_peak = 1
                    elif polarization == "cp":
                        self.calc.source_type = (
                            self.calc.SourceType.elliptic_undulator
                        )
                        self.calc.bx_peak = 1
                        self.calc.by_peak = source.fields_ratio
                    else:
                        return

                    self.calc.k_range = [kmin, kmax]
                    self.calc.period = source.period

            else:
                flag_bend = True
                b = source.b_peak
                self.calc.source_type = self.calc.SourceType.bending_magnet
                self.calc.method = self.calc.CalcConfigs.Method.far_field
                self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                self.calc.output_type = self.calc.CalcConfigs.Output.flux
                self.calc.slit_shape = slit_shape
                self.calc.observation_angle = [0, 0]
                self.calc.slit_acceptance = slit_acceptances[i]
                self.calc.energy_range = energy_range
                self.calc.energy_step = 1
                self.calc.by_peak = b

            self.calc.length = source.source_length

            if beta_sections is not None:
                if beta_sections[i] == "high":
                    self.accelerator.set_high_beta_section()
                elif beta_sections[i] == "low":
                    self.accelerator.set_low_beta_section()
                elif beta_sections[i] == "b2":
                    self.accelerator.set_b2_section()
                elif beta_sections[i] == "bc":
                    self.accelerator.set_bc_section()
                elif beta_sections[i] == "b1":
                    self.accelerator.set_b1_section()
                else:
                    raise ValueError("Invalid beta section.")

            self.calc.set_config()
            self.calc.run_calculation()

            energies.append(self.calc.energies)
            fluxes.append(self.calc.flux)

        if flag_bend:
            energies = _np.array(energies, dtype=object)
            fluxes = _np.array(fluxes, dtype=object)
        else:
            energies = _np.array(energies)
            fluxes = _np.array(fluxes)

        self._energies = energies
        self._fluxes = fluxes

    def calc_k_target(self, n: int, period: float, target_energy: float):
        """Calc k for target energy given harmonic number and period.

        Args:
            n (int): harmonic number.
            period (float): undulator period [mm].
            target_energy (float): target energy of radiation [eV].

        Returns:
            float: K value
        """
        gamma = self.accelerator.gamma
        arg = (
            2
            * n
            * gamma**2
            * PLANCK
            * 2
            * _np.pi
            * LSPEED
            / (target_energy * ECHARGE * 1e-3 * period)
            - 1
        )
        return _np.sqrt(2) * _np.sqrt(arg)

    def _calc_flux_density(
        self,
        target_energy: float,
        source_period: float,
        source_length: float,
        target_k: float,
    ):
        """Calculate flux density for one k value.

        Args:
            target_energy (float): target energy of radiation [eV].
            source_period (float): undulator period [mm].
            source_length (float): undulator length [m].
            target_k (float): K value.

        Returns:
            _type_: _description_
        """
        self._target_energy = target_energy
        und: Undulator = self._und

        # Spectra Initialization
        spectra = SpectraInterface()
        spectra.accelerator.set_bsc_with_ivu18()
        if self.accelerator.beta_section == "low":
            spectra.accelerator.set_low_beta_section()
        else:
            spectra.accelerator.set_high_beta_section()

        # Spectra Configuration
        spectra.accelerator.zero_emittance = self.accelerator.zero_emittance
        spectra.accelerator.zero_energy_spread = (
            self.accelerator.zero_emittance
        )

        if und.polarization == "hp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.horizontal_undulator
            )
            spectra.calc.ky = target_k
        elif und.polarization == "vp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.vertical_undulator
            )
            spectra.calc.kx = target_k
        else:
            spectra.calc.source_type = (
                spectra.calc.SourceType.elliptic_undulator
            )
            spectra.calc.kx = target_k / _np.sqrt(1 + und.fields_ratio**2)
            spectra.calc.ky = spectra.calc.kx * und.fields_ratio

        spectra.calc.output_type = spectra.calc.CalcConfigs.Output.flux_density
        spectra.calc.method = spectra.calc.CalcConfigs.Method.far_field
        spectra.calc.output_type = self.calc.output_type

        spectra.calc.distance_from_source = 1
        spectra.calc.observation_angle = [0, 0]
        spectra.calc.energy_range = [
            self._target_energy,
            self._target_energy + 0.01,
        ]
        spectra.calc.energy_step = 0.01

        # Spectra calculation
        spectra.calc.period = source_period
        spectra.calc.length = source_length
        spectra.calc.set_config()
        spectra.calc.run_calculation()

        return [_np.max(spectra.calc.flux), target_k]

    def _parallel_calc_flux_density(self, args):
        target_k, period, length, *_ = args
        return self._calc_flux_density(
            self._target_energy, period, length, target_k
        )

    def calc_flux_density_matrix(  # noqa: C901
        self,
        target_energy: float,
        und,
        period_range: tuple = (18, 30),
        nr_pts_period: int = 20,
        length_range: tuple = (1, 3),
        nr_pts_length: int = 20,
        n_harmonic_truc: int = 15,
    ):
        """Calc flux density matrix.

        Args:
            target_energy (float): Target energy [eV]
            und (Undulator object): Must be an object from undulator class.
            nr_pts_period (int, optional): Number of period points.
                Defaults to 20.
            period_range (tuple): length range to use in the calculation
            nr_pts_length (int, optional): Number of length points.
                Defaults to 20.
            length_range (tuple): length range to use in the calculation
            n_harmonic_truc (int, optional): Harmonic number to truncate
                the calculation. Defaults to 15.

        Returns:
            numpy array: Flux matrix.
            numpy array: Undulators information.
        """
        gamma = self.accelerator.gamma
        self._target_energy = target_energy
        self._und = und
        periods = _np.linspace(period_range[0], period_range[1], nr_pts_period)
        lengths = _np.linspace(length_range[0], length_range[1], nr_pts_length)

        # Arglist assembly
        arglist = []
        for length in lengths:
            for period in periods:
                self._und.period = period
                self._und.source_length = length

                k_max = und.calc_max_k(self.accelerator)
                ky = 0
                kx = 0

                n = 1
                while (
                    self._und.get_harmonic_energy(
                        n, gamma, 0, self._und.period, k_max
                    )
                    < self._target_energy
                ):
                    n += 1
                if n > 1:
                    n -= 1

                n_truc = n_harmonic_truc

                if n > n_truc:
                    n = n_truc

                ns = _np.linspace(1, n, int(n))

                target_ks = self.calc_k_target(
                    ns, self._und.period, self._target_energy
                )

                if target_ks[0] > k_max:
                    target_ks[0] = 0

                idx = _np.isnan(target_ks)
                idx = _np.where(idx)

                target_ks[idx] = 0
                for i, target_k in enumerate(target_ks):
                    if self._und.polarization == "hp":
                        ky = target_k
                    elif self._und.polarization == "vp":
                        kx = target_k
                    elif self._und.polarization == "cp":
                        kx = target_k / _np.sqrt(1 + self._und.fields_ratio**2)
                        ky = kx * self._und.fields_ratio

                    gap = self._und.undulator_k_to_gap(
                        k=target_k,
                        period=self._und.period,
                        br=self._und.br,
                        a=self._und.halbach_coef[self._und.polarization]["a"],
                        b=self._und.halbach_coef[self._und.polarization]["b"],
                        c=self._und.halbach_coef[self._und.polarization]["c"],
                    )
                    arglist += [(target_k, period, length, ns[i], gap, ky, kx)]

        # Parallel calculations
        num_processes = multiprocessing.cpu_count()
        data = []
        with multiprocessing.Pool(processes=num_processes - 1) as parallel:
            data = parallel.map(self._parallel_calc_flux_density, arglist)

        arglist = _np.array(arglist, dtype="object")
        arglist = arglist[:, [0, 1, 2, 3, 4, 5, 6]]
        result = _np.array(data)

        # Identification of breaks with equal length and equal periods
        idx_broke = list(
            _np.where(
                (arglist[:-1, 1] != arglist[1:, 1])
                | (arglist[:-1, 2] != arglist[1:, 2])
            )[0]
        )
        idx_broke.append(len(arglist) - 1)

        i_start = 0
        filter_arglist = []
        filter_result = []

        for i in idx_broke:
            collection_arg = []
            collection_result = []
            for j in range(i_start, i + 1):
                collection_arg.append(list(arglist[j]))
                collection_result.append(list(result[j]))
            i_start = i + 1
            filter_arglist.append(collection_arg)
            filter_result.append(collection_result)

        # Selection of the best results for a given period and length
        best_result = []
        info_unds = []

        for i, fluxs_densenties in enumerate(filter_result):
            arr = _np.array(fluxs_densenties)[:, 0]
            best_result.append(fluxs_densenties[_np.argmax(arr)])
            info_unds.append(filter_arglist[i][_np.argmax(arr)])

        best_result = _np.array(best_result)
        info_unds = _np.array(info_unds)

        # Flux Density Matrix Reassembly
        flux_density_matrix = best_result[:, 0]
        flux_density_matrix = flux_density_matrix.reshape(
            len(periods), len(lengths), order="F"
        )
        flux_density_matrix = flux_density_matrix.transpose()

        self._flux_density_matrix = flux_density_matrix
        self._info_matrix_flux_density = info_unds

        return flux_density_matrix, info_unds

    def _calc_flux(
        self,
        target_energy: float,
        source_period: float,
        source_length: float,
        target_k: float,
        slit_shape: str,
        slit_acceptance: list,
        distance_from_source: float,
        method: str,
        n_harmonic: int,
    ):
        """Calculate flux for one k value.

        Args:
            target_energy (float): target energy of radiation [eV].
            source_period (float): undulator period [mm].
            source_length (float): undulator length [m].
            target_k (float): K value.
            slit_shape (str): shape of slit acceptance 'retslit' or 'circslit'.
            slit_acceptance (list): slit aceeptance [mrad, mrad].
            distance_from_source (float): distance from the source [m]
            method (int): method to use in fixed point calculation 'farfield' or 'nearfield'
            n_harmonic (int): harmonic number to used in the calculation
        Returns:
            _type_: _description_
        """  # noqa: E501
        self._target_energy = target_energy
        und: Undulator = self._und

        # Spectra Initialization
        spectra = SpectraInterface()
        spectra.accelerator.set_bsc_with_ivu18()
        if self.accelerator.beta_section == "low":
            spectra.accelerator.set_low_beta_section()
        else:
            spectra.accelerator.set_high_beta_section()

        # Spectra Configuration
        spectra.accelerator.zero_emittance = self.accelerator.zero_emittance
        spectra.accelerator.zero_energy_spread = (
            self.accelerator.zero_emittance
        )

        if und.polarization == "hp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.horizontal_undulator
            )
            spectra.calc.ky = target_k
        elif und.polarization == "vp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.vertical_undulator
            )
            spectra.calc.kx = target_k
        else:
            spectra.calc.source_type = (
                spectra.calc.SourceType.elliptic_undulator
            )
            spectra.calc.kx = target_k / _np.sqrt(1 + und.fields_ratio**2)
            spectra.calc.ky = spectra.calc.kx * und.fields_ratio

        if method == "farfield":
            spectra.calc.method = (
                spectra.calc.CalcConfigs.Method.fixedpoint_far_field
            )
        elif method == "nearfield":
            spectra.calc.method = (
                spectra.calc.CalcConfigs.Method.fixedpoint_near_field
            )

        spectra.calc.indep_var = spectra.calc.CalcConfigs.Variable.energy
        spectra.calc.output_type = spectra.calc.CalcConfigs.Output.flux

        if slit_shape == "retslit":
            spectra.calc.slit_shape = (
                spectra.calc.CalcConfigs.SlitShape.rectangular
            )
        elif slit_shape == "circslit":
            spectra.calc.slit_shape = (
                spectra.calc.CalcConfigs.SlitShape.circular
            )

        spectra.calc.target_energy = self._target_energy
        spectra.calc.distance_from_source = distance_from_source
        spectra.calc.observation_angle = [0, 0]
        spectra.calc.slit_acceptance = slit_acceptance

        # Spectra calculation
        spectra.calc.period = source_period
        spectra.calc.length = source_length
        spectra.calc.set_config()
        spectra.calc.run_calculation()
        if und.add_phase_errors:
            rec_param = und.use_recovery_params
            flux = spectra.apply_phase_error_matrix(
                _np.max(spectra.calc.flux), n_harmonic, rec_param=rec_param
            )
        else:
            flux = _np.max(spectra.calc.flux)
        return flux

    def _parallel_calc_flux(self, args):
        (
            target_k,
            period,
            length,
            n_harmonic,
            distance_from_source,
            slit_x,
            slit_y,
            method,
            _,
            slit_shape,
            *_,
        ) = args
        slit_acceptance = [slit_x, slit_y]
        return self._calc_flux(
            self._target_energy,
            period,
            length,
            target_k,
            slit_shape,
            slit_acceptance,
            distance_from_source,
            method,
            n_harmonic,
        )

    def calc_flux_matrix(  # noqa: C901
        self,
        target_energy: float,
        und: Undulator,
        period_range: tuple = (18, 30),
        nr_pts_period: int = 20,
        length_range: tuple = (1, 3),
        nr_pts_length: int = 20,
        n_harmonic_truc: int = 15,
        slit_shape: str = "retslit",
        slit_acceptance: list = [0.230, 0.230],
        distance_from_source: float = 23,
        method: str = "farfield",
        nr_pts_k: int = 1,
        delta_k_range=_np.array([0.99]),
        min_k_max: float = 0.1,
    ):
        """Calc flux matrix.

        Args:
            target_energy (float): Target energy [eV]
            und (Undulator object): Must be an object from undulator class.
            period_range (tuple): Period range for calculation [mm]
                Defaults to (18,30) mm
            nr_pts_period (int, optional): Number of period points.
                Defaults to 20.
            length_range (tuple): Length range for calculation [m]
                Defaults to (1,3) m
            nr_pts_length (int, optional): Number of length points.
                Defaults to 20.
            n_harmonic_truc (int, optional): Harmonic number to truncate
                the calculation. Defaults to 15.
            slit_shape: (str): shape of slit acceptance 'retslit' or 'circslit'
                Defaults to 'retslit'.
            slit_acceptance (list): Slit acceptance [mrad, mrad].
                Defaults to [0.230, 0.230]
            distance_from_source (float): Distance from the source [m]
                Defaults to 23
            method (str): method to use in fixed point calculation 'farfield' or 'nearfield'
                Defaults to 'farfield'
            nr_pts_k (int): number to otimize the tuned beam
            delta_k_range (array): multiplicative factor for the K-value at resonance. 
                Defines the lowest K-value. Each element will be applied to the respective harmonic number.
                If n_harmonic > len(delta_k_range), the last value will be used for the next harmonics. 
            min_k_max (float): min k max to remove the holes in the flux curve
        Returns:
            numpy array: Flux matrix.
            numpy array: Undulators information.
        """
        gamma = self.accelerator.gamma
        self._target_energy = target_energy
        self._und = und
        periods = _np.linspace(period_range[0], period_range[1], nr_pts_period)
        lengths = _np.linspace(length_range[0], length_range[1], nr_pts_length)

        # Arglist assembly
        arglist = []
        for length in lengths:
            for period in periods:
                self._und.period = period
                self._und.source_length = length

                k_max = self._und.calc_max_k(self.accelerator)

                if k_max >= min_k_max:
                    kx = 0
                    ky = 0

                    n = 1
                    en = self._und.get_harmonic_energy(
                        n, gamma, 0, self._und.period, k_max
                    )
                    while en < self._target_energy:
                        n += 2
                        en = self._und.get_harmonic_energy(
                            n, gamma, 0, self._und.period, k_max
                        )
                    if n > 2:
                        n -= 2

                    n_truc = n_harmonic_truc

                    if n > n_truc:
                        n = n_truc

                    ns = _np.linspace(1, n, int(n / 2 + 1))

                    target_ks = self.calc_k_target(
                        ns, self._und.period, self._target_energy
                    )

                    target_ks[_np.where(target_ks > k_max)[0]] = 0
                    idx = _np.isnan(target_ks)
                    idx = _np.where(idx)
                    target_ks[idx[-1]] = 0
                    new_idx = _np.delete(idx, [-1])
                    target_ks = _np.delete(target_ks, new_idx)

                    for i, target_k in enumerate(target_ks):
                        if i < len(delta_k_range):
                            ks = _np.linspace(
                                target_k, target_k * delta_k_range[i], nr_pts_k
                            )
                        else:
                            ks = _np.linspace(
                                target_k,
                                target_k * delta_k_range[-1],
                                nr_pts_k,
                            )
                        # k = target_k
                        ks = _np.delete(ks, _np.where(ks < 0)[0])

                        for k in ks:
                            gap = self._und.undulator_k_to_gap(
                                k=k,
                                period=self._und.period,
                                br=self._und.br,
                                a=self._und.halbach_coef[
                                    self._und.polarization
                                ]["a"],
                                b=self._und.halbach_coef[
                                    self._und.polarization
                                ]["b"],
                                c=self._und.halbach_coef[
                                    self._und.polarization
                                ]["c"],
                            )
                            if self._und.polarization == "hp":
                                ky = k
                            elif self._und.polarization == "vp":
                                kx = k
                            elif self._und.polarization == "cp":
                                kx = k / _np.sqrt(
                                    1 + self._und.fields_ratio**2
                                )
                                ky = kx * self._und.fields_ratio

                            arglist += [
                                (
                                    k,
                                    period,
                                    length,
                                    ns[i],
                                    distance_from_source,
                                    slit_acceptance[0],
                                    slit_acceptance[1],
                                    method,
                                    gap,
                                    slit_shape,
                                    ky,
                                    kx,
                                )
                            ]
                else:
                    arglist += [
                        (
                            0,
                            period,
                            length,
                            1,
                            distance_from_source,
                            slit_acceptance[0],
                            slit_acceptance[1],
                            method,
                            _np.inf,
                            slit_shape,
                            0,
                            0,
                        )
                    ]

        # Parallel calculations
        num_processes = multiprocessing.cpu_count()
        data = []
        with multiprocessing.Pool(processes=num_processes - 1) as parallel:
            data = parallel.map(self._parallel_calc_flux, arglist)

        arglist = _np.array(arglist, dtype="object")
        arglist = arglist[:, [0, 1, 2, 3, 8, 10, 11]]
        result = _np.array(data)

        # Identification of breaks with equal length and equal periods
        idx_broke = list(
            _np.where(
                (arglist[:-1, 1] != arglist[1:, 1])
                | (arglist[:-1, 2] != arglist[1:, 2])
            )[0]
        )
        idx_broke.append(len(arglist) - 1)

        i_start = 0
        filter_arglist = []
        filter_result = []

        for i in idx_broke:
            collection_arg = []
            collection_result = []
            for j in range(i_start, i + 1):
                collection_arg.append(list(arglist[j]))
                collection_result.append(result[j])
            i_start = i + 1
            filter_arglist.append(collection_arg)
            filter_result.append(collection_result)

        # Selection of the best results for a given period and length
        best_result = []
        info_unds = []

        for i, fluxs in enumerate(filter_result):
            arr = _np.array(fluxs)
            best_result.append(fluxs[_np.argmax(arr)])
            info_unds.append(filter_arglist[i][_np.argmax(arr)])

        best_result = _np.array(best_result)
        info_unds = _np.array(info_unds)

        # Flux Matrix Reassembly
        flux_matrix = best_result
        flux_matrix = flux_matrix.reshape(
            len(periods), len(lengths), order="F"
        )
        flux_matrix = flux_matrix.transpose()

        self._flux_matrix = flux_matrix
        self._info_matrix_flux = info_unds

        return flux_matrix, info_unds

    def _calc_brilliance(
        self,
        target_harmonic: float,
        source_period: float,
        source_length: float,
        target_k: float,
        flag_fix_point_method: int,
    ):
        """Calculate brilliance for one k value.

        Args:
            target_harmonic (float): target harmonic number of radiation energy [eV].
            source_period (float): undulator period [mm].
            source_length (float): undulator length [m].
            target_k (float): K value.
            flag_fix_point_method (int): flag to select method
        Returns:
            _type_: _description_
        """
        und: Undulator = self._und

        # Spectra Initialization
        spectra = SpectraInterface()
        spectra.accelerator.set_bsc_with_ivu18()
        if self.accelerator.beta_section == "low":
            spectra.accelerator.set_low_beta_section()
        else:
            spectra.accelerator.set_high_beta_section()

        # Spectra Configuration
        spectra.accelerator.zero_emittance = self.accelerator.zero_emittance
        spectra.accelerator.zero_energy_spread = (
            self.accelerator.zero_emittance
        )

        spectra.calc.output_type = spectra.calc.CalcConfigs.Output.brilliance
        if flag_fix_point_method == 1:
            spectra.calc.method = (
                spectra.calc.CalcConfigs.Method.fixedpoint_wigner
            )
            spectra.calc.indep_var = spectra.calc.CalcConfigs.Variable.energy
        else:
            spectra.calc.method = spectra.calc.CalcConfigs.Method.wigner
            spectra.calc.indep_var = spectra.calc.CalcConfigs.Variable.k

        if und.polarization == "hp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.horizontal_undulator
            )
            spectra.calc.ky = target_k
        elif und.polarization == "vp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.vertical_undulator
            )
            spectra.calc.kx = target_k
        else:
            spectra.calc.source_type = (
                spectra.calc.SourceType.elliptic_undulator
            )
            spectra.calc.kx = target_k / _np.sqrt(1 + und.fields_ratio**2)
            spectra.calc.ky = spectra.calc.kx * und.fields_ratio

        if flag_fix_point_method == 1:
            spectra.calc.target_harmonic = int(target_harmonic)
        else:
            spectra.calc.harmonic_range = [target_harmonic, target_harmonic]
            spectra.calc.k_range = [0, target_k]
            spectra.calc.k_nr_pts = 2

        spectra.calc.slice_x = 0
        spectra.calc.slice_px = 0
        spectra.calc.slice_y = 0
        spectra.calc.slice_py = 0

        # Spectra calculation
        spectra.calc.period = source_period
        spectra.calc.length = source_length

        spectra.calc.set_config()
        spectra.calc.run_calculation()
        if und.add_phase_errors:
            rec_param = und.use_recovery_params
            brilliance = spectra.apply_phase_error_matrix(
                _np.max(spectra.calc.brilliance),
                target_harmonic,
                rec_param=rec_param,
            )
        else:
            brilliance = _np.max(spectra.calc.brilliance)

        return brilliance

    def _parallel_calc_brilliance(self, args):
        (
            target_k,
            period,
            length,
            n_harmonic,
            flag_fix_point_method,
            gap,
            ky,
            kx,
        ) = args
        return self._calc_brilliance(
            n_harmonic, period, length, target_k, flag_fix_point_method
        )

    def calc_brilliance_matrix(  # noqa: C901
        self,
        target_energy: float,
        und: Undulator,
        period_range: tuple = (18, 30),
        nr_pts_period: int = 20,
        length_range: tuple = (1, 3),
        nr_pts_length: int = 20,
        n_harmonic_truc: int = 15,
        fixed_point_method: bool = False,
    ):
        """Calc brilliance matrix.

        Args:
            target_energy (float): Target energy [eV]
            und (Undulator object): Must be an object from undulator class.
            nr_pts_period (int, optional): Number of period points.
                Defaults to 20.
            period_range (tuple): length range to use in the calculation
            nr_pts_length (int, optional): Number of length points.
                Defaults to 20.
            length_range (tuple): length range to use in the calculation
            n_harmonic_truc (int, optional): Harmonic number to truncate
                the calculation. Defaults to 15.
            fixed_point_method (bool): Fixed Point Calculation method with wigner function.
                Defaults to False

        Returns:
            numpy array: Brilliance matrix.
            numpy array: Undulators information.
        """
        gamma = self.accelerator.gamma
        self._target_energy = target_energy
        self._und = und
        periods = _np.linspace(period_range[0], period_range[1], nr_pts_period)
        lengths = _np.linspace(length_range[0], length_range[1], nr_pts_length)

        flag_fix_point_method = 1 if fixed_point_method else 0

        # Arglist assembly
        arglist = []
        for length in lengths:
            for period in periods:
                self._und.period = period
                self._und.source_length = length

                k_max = und.calc_max_k(self.accelerator)
                ky = 0
                kx = 0

                n = 1
                while (
                    self._und.get_harmonic_energy(
                        n, gamma, 0, self._und.period, k_max
                    )
                    < self._target_energy
                ):
                    n += 2
                if n > 2:
                    n -= 2

                n_truc = n_harmonic_truc

                if n > n_truc:
                    n = n_truc

                ns = _np.linspace(1, n, int(n / 2 + 1))

                target_ks = self.calc_k_target(
                    ns, self._und.period, self._target_energy
                )

                if target_ks[0] > k_max:
                    target_ks[0] = 0

                idx = _np.isnan(target_ks)
                idx = _np.where(idx == True)

                target_ks[idx] = 0
                for i, target_k in enumerate(target_ks):
                    if self._und.polarization == "hp":
                        ky = target_k
                    elif self._und.polarization == "vp":
                        kx = target_k
                    elif self._und.polarization == "cp":
                        kx = target_k / _np.sqrt(1 + self._und.fields_ratio**2)
                        ky = kx * self._und.fields_ratio

                    gap = self._und.undulator_k_to_gap(
                        k=target_k,
                        period=self._und.period,
                        br=self._und.br,
                        a=self._und.halbach_coef[self._und.polarization]["a"],
                        b=self._und.halbach_coef[self._und.polarization]["b"],
                        c=self._und.halbach_coef[self._und.polarization]["c"],
                    )
                    arglist += [
                        (
                            target_k,
                            period,
                            length,
                            ns[i],
                            flag_fix_point_method,
                            gap,
                            ky,
                            kx,
                        )
                    ]

        # Parallel calculations
        num_processes = multiprocessing.cpu_count()
        data = []
        with multiprocessing.Pool(processes=num_processes - 1) as parallel:
            data = parallel.map(self._parallel_calc_brilliance, arglist)

        arglist = _np.array(arglist, dtype="object")
        arglist = arglist[:, [0, 1, 2, 3, 5, 6, 7]]
        result = _np.array(data)

        # Identification of breaks with equal length and equal periods
        idx_broke = list(
            _np.where(
                (arglist[:-1, 1] != arglist[1:, 1])
                | (arglist[:-1, 2] != arglist[1:, 2])
            )[0]
        )
        idx_broke.append(len(arglist) - 1)

        i_start = 0
        filter_arglist = []
        filter_result = []

        for i in idx_broke:
            collection_arg = []
            collection_result = []
            for j in range(i_start, i + 1):
                collection_arg.append(list(arglist[j]))
                collection_result.append(result[j])
            i_start = i + 1
            filter_arglist.append(collection_arg)
            filter_result.append(collection_result)

        # Selection of the best results for a given period and length
        best_result = []
        info_unds = []

        for i, brilliances in enumerate(filter_result):
            arr = _np.array(brilliances)
            best_result.append(brilliances[_np.argmax(arr)])
            info_unds.append(filter_arglist[i][_np.argmax(arr)])

        best_result = _np.array(best_result)
        info_unds = _np.array(info_unds)

        # Brilliance Matrix Reassembly
        brilliance_matrix = best_result
        brilliance_matrix = brilliance_matrix.reshape(
            len(periods), len(lengths), order="F"
        )
        brilliance_matrix = brilliance_matrix.transpose()

        self._brilliance_matrix = brilliance_matrix
        self._info_matrix_brilliance = info_unds

        return brilliance_matrix, info_unds

    def _calc_partial_power(
        self,
        source_period: float,
        source_length: float,
        target_k: float,
        slit_acceptance: list,
        distance_from_source: float,
        calcfarfield: int,
    ):
        """Calculate partial power for one k value.

        Args:
            target_energy (float): target energy of radiation [eV].
            source_period (float): undulator period [mm].
            source_length (float): undulator length [m].
            target_k (float): K value.
            slit_acceptance (list): slit aceeptance [mrad, mrad].
            distance_from_source (float): distance from the source [m]
            calcfarfield (int): method to use in fixed point calculation 'farfield' 1 or 'nearfield' 0

        Returns:
            _type_: _description_
        """
        und: Undulator = self._und

        # Spectra Initialization
        spectra = SpectraInterface()
        spectra.accelerator.set_bsc_with_ivu18()
        if self.accelerator.beta_section == "low":
            spectra.accelerator.set_low_beta_section()
        else:
            spectra.accelerator.set_high_beta_section()

        # Spectra Configuration
        spectra.accelerator.zero_emittance = self.accelerator.zero_emittance
        spectra.accelerator.zero_energy_spread = (
            self.accelerator.zero_emittance
        )

        if und.polarization == "hp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.horizontal_undulator
            )
            spectra.calc.ky = target_k
        elif und.polarization == "vp":
            spectra.calc.source_type = (
                spectra.calc.SourceType.vertical_undulator
            )
            spectra.calc.kx = target_k
        else:
            spectra.calc.source_type = (
                spectra.calc.SourceType.elliptic_undulator
            )
            spectra.calc.kx = target_k / _np.sqrt(1 + und.fields_ratio**2)
            spectra.calc.ky = spectra.calc.kx * und.fields_ratio

        if calcfarfield == 1:
            spectra.calc.method = (
                spectra.calc.CalcConfigs.Method.fixedpoint_far_field
            )
        elif calcfarfield == 0:
            spectra.calc.method = (
                spectra.calc.CalcConfigs.Method.fixedpoint_near_field
            )

        spectra.calc.indep_var = spectra.calc.CalcConfigs.Variable.energy
        spectra.calc.output_type = spectra.calc.CalcConfigs.Output.power
        spectra.calc.slit_shape = (
            spectra.calc.CalcConfigs.SlitShape.rectangular
        )

        spectra.calc.target_energy = self._target_energy
        spectra.calc.distance_from_source = distance_from_source
        spectra.calc.observation_angle = [0, 0]
        spectra.calc.slit_acceptance = slit_acceptance

        # Spectra calculation
        spectra.calc.period = source_period
        spectra.calc.length = source_length
        spectra.calc.set_config()
        spectra.calc.run_calculation()

        return spectra.calc.power

    def _parallel_calc_partial_power(self, args):
        (
            target_k,
            period,
            length,
            distance_from_source,
            slit_x,
            slit_y,
            method,
        ) = args
        slit_acceptance = [slit_x, slit_y]
        return self._calc_partial_power(
            period,
            length,
            target_k,
            slit_acceptance,
            distance_from_source,
            method,
        )

    def calc_partial_power_from_matrix(
        self,
        data: tuple,
        slit_acceptance: list = [0.230, 0.230],  # noqa: B006
        distance_from_source: float = 30,
        method: str = "farfield",
    ):
        """Calc partial power from matrix.

        Args:
            slit_acceptance (list): Slit acceptance [mrad, mrad].
             Defaults to [0.230, 0.230]
            distance_from_source (float): Distance from the source [m]
             Defaults to 10
            method (str): method to use in fixed point calculation 'farfield' or 'nearfield'
             Defaults to 'farfield'
            data (tuple): data especified to use in calculation
             First position 'flux matrix' or 'flux density matrix' or 'brilliance matrix'
             Second position unds matrix
        Returns:
            numpy array: partial power matrix.
        """
        if data is None:
            raise ValueError("'data' parameter has to be defined")

        unds_matrix = data[1]
        info_unds_matrix = unds_matrix

        calcfarfield = 1 if method == "farfield" else 0

        # Arglist assembly
        arglist = info_unds_matrix[:, [0, 1, 2]]

        # Add distance from the source
        arglist = _np.c_[
            arglist, _np.ones((arglist.shape[0], 1)) * distance_from_source
        ]
        # Add slit x
        arglist = _np.c_[
            arglist, _np.ones((arglist.shape[0], 1)) * slit_acceptance[0]
        ]
        # Add slit y
        arglist = _np.c_[
            arglist, _np.ones((arglist.shape[0], 1)) * slit_acceptance[1]
        ]
        # Add method farfield or nearfield
        arglist = _np.c_[
            arglist, _np.ones((arglist.shape[0], 1)) * calcfarfield
        ]

        arglist = list(arglist)

        # Parallel calculations
        num_processes = multiprocessing.cpu_count()
        data = []
        with multiprocessing.Pool(processes=num_processes - 1) as parallel:
            data = parallel.map(self._parallel_calc_partial_power, arglist)

        arglist = _np.array(arglist)
        result = _np.array(data)

        # Partial power Matrix Reassembly
        pts_period = len(_np.where(arglist[:, 2] == arglist[0, 2])[0])
        pts_length = len(_np.where(arglist[:, 1] == arglist[0, 1])[0])

        partial_power_matrix = result.reshape(pts_length, pts_period)

        return partial_power_matrix

    def plot_brilliance_curve(  # noqa: C901
        self,
        process_curves=True,
        superp_value=250,
        title="Brilliance curves",
        xscale="linear",
        yscale="log",
        xlim=[],
        ylim=[],
        linewidth=3,
        savefig=False,
        figsize=(4.5, 3.0),
        figname="brill.png",
        dpi=300,
        legend_fs=10,
        legend_properties=True,
    ):
        """Plot brilliance curves.

        Args:
            process_curves (bool, optional): If true energy superposition will
             be processed. Defaults to True.
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.
            title (str, optional): Plot title.
            xscale (str, optional): xscale axis
             xscale. Defalts to 'linear'.
            yscale (str, optional): yscale axis
             yscale. Defalts to 'log'.
        """
        if self._flag_brill_processed:
            process_curves = False
        energies = list()
        brilliances = list()
        if process_curves is True:
            self._flag_brill_processed = True
            for i, source in enumerate(self.sources):
                if (
                    source.source_type != "wiggler"
                    and source.source_type != "bendingmagnet"
                ):
                    input_brilliance = self.brilliances[i][:, :]
                    input_energies = self.energies[i][:, :]
                    if input_energies.shape[0] > 1:
                        energies_, brilliance = (
                            self.calc.process_brilliance_curve(
                                input_energies,
                                input_brilliance,
                                superp_value=superp_value,
                            )
                        )
                    else:
                        input_brilliance_b = input_brilliance[0]
                        input_energies_b = input_energies[0]
                        idx = _np.argsort(input_energies_b)
                        input_energies_b = input_energies_b[idx]
                        input_brilliance_b = input_brilliance_b[idx]
                        energies_ = _np.linspace(
                            _np.min(input_energies_b),
                            _np.max(input_energies_b),
                            2001,
                        )
                        brilliance = _np.interp(
                            energies_, input_energies_b, input_brilliance_b
                        )
                        energies_ = _np.reshape(
                            energies_, (1, _np.shape(energies_)[0])
                        )
                        brilliance = _np.reshape(
                            brilliance, (1, _np.shape(brilliance)[0])
                        )
                else:
                    input_brilliance = _np.array(
                        self.brilliances[i], dtype=float
                    )
                    input_energies = _np.array(self.energies[i], dtype=float)
                    energies_ = _np.linspace(
                        _np.min(input_energies), _np.max(input_energies), 2001
                    )
                    brilliance = _np.interp(
                        energies_, input_energies, input_brilliance
                    )
                    energies_ = _np.reshape(
                        energies_, (1, _np.shape(energies_)[0])
                    )
                    brilliance = _np.reshape(
                        brilliance, (1, _np.shape(brilliance)[0])
                    )

                energies.append(energies_)
                brilliances.append(brilliance)
            energies = _np.array(energies, dtype=object)
            brilliances = _np.array(brilliances, dtype=object)
            self._energies = energies
            self._brilliances = brilliances

        _plt.figure(figsize=figsize)
        colorlist = ["C0", "C1", "C2", "C3", "C4", "C5"]
        for i, source in enumerate(self.sources):
            color = colorlist[i]
            if source.source_type == "bendingmagnet":
                label = source.label
            else:
                label = source.label
                if legend_properties:
                    label += ", λ = {:.1f} mm".format(source.period)
                    label += ", L = {:.1f} m".format(source.source_length)
            for j in _np.arange(self.energies[i].shape[0]):
                if j == 0:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.brilliances[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                        label=label,
                    )
                else:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.brilliances[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                    )

        _plt.yscale(yscale)
        _plt.xscale(xscale)

        if xlim:
            _plt.xlim(xlim[0], xlim[1])
        if ylim:
            _plt.ylim(ylim[0], ylim[1])

        _plt.xlabel("Energy [keV]")
        _plt.ylabel("Brilliance [ph/s/0.1%/mm²/mrad²/100mA]")
        _plt.title(title)

        _plt.minorticks_on()
        _plt.tick_params(
            which="both", axis="both", direction="in", top=True, right=True
        )
        _plt.grid(which="major", alpha=0.4)
        _plt.grid(which="minor", alpha=0.2)

        _plt.legend(fontsize=legend_fs)
        _plt.tight_layout()

        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_flux_curve(  # noqa: C901
        self,
        process_curves=True,
        superp_value=250,
        title="Flux curves",
        xscale="linear",
        yscale="log",
        xlim=[],
        ylim=[],
        linewidth=3,
        savefig=False,
        figsize=(4.5, 3.0),
        figname="flux.png",
        dpi=300,
        legend_fs=10,
        legend_properties=True,
    ):
        """Plot flux curves.

        Args:
            process_curves (bool, optional): If true energy superposition will
             be processed. Defaults to True.
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.
            title (str, optional): Plot title.
            xscale (str, optional): xscale axis
             xscale. Defalts to 'linear'.
            yscale (str, optional): yscale axis
             yscale. Defalts to 'log'.
        """
        if self._flag_flux_processed:
            process_curves = False
        energies = list()
        fluxes = list()
        if process_curves is True:
            self._flag_flux_processed = True
            for i, source in enumerate(self.sources):
                if (
                    source.source_type != "wiggler"
                    and source.source_type != "bendingmagnet"
                ):
                    input_flux = self.fluxes[i][:, :]
                    input_energies = self.energies[i][:, :]
                    if input_energies.shape[0] > 1:
                        energies_, flux = self.calc.process_brilliance_curve(
                            input_energies,
                            input_flux,
                            superp_value=superp_value,
                        )
                    else:
                        input_flux_b = input_flux[0]
                        input_energies_b = input_energies[0]
                        idx = _np.argsort(input_energies_b)
                        input_energies_b = input_energies_b[idx]
                        input_flux_b = input_flux_b[idx]
                        energies_ = _np.linspace(
                            _np.min(input_energies_b),
                            _np.max(input_energies_b),
                            2001,
                        )
                        flux = _np.interp(
                            energies_, input_energies_b, input_flux_b
                        )
                        energies_ = _np.reshape(
                            energies_, (1, _np.shape(energies_)[0])
                        )
                        flux = _np.reshape(flux, (1, _np.shape(flux)[0]))
                else:
                    input_flux = _np.array(self.fluxes[i], dtype=float)
                    input_energies = _np.array(self.energies[i], dtype=float)
                    energies_ = _np.linspace(
                        _np.min(input_energies), _np.max(input_energies), 2001
                    )
                    flux = _np.interp(energies_, input_energies, input_flux)
                    energies_ = _np.reshape(
                        energies_, (1, _np.shape(energies_)[0])
                    )
                    flux = _np.reshape(flux, (1, _np.shape(flux)[0]))

                energies.append(energies_)
                fluxes.append(flux)
            energies = _np.array(energies, dtype=object)
            fluxes = _np.array(fluxes, dtype=object)
            self._energies = energies
            self._fluxes = fluxes

        _plt.figure(figsize=figsize)
        colorlist = ["C0", "C1", "C2", "C3", "C4", "C5"]
        for i, source in enumerate(self.sources):
            color = colorlist[i]
            if source.source_type == "bendingmagnet":
                label = source.label
            else:
                label = source.label
                if legend_properties:
                    label += ", λ = {:.1f} mm".format(source.period)
                    label += ", L = {:.1f} m".format(source.source_length)
            for j in _np.arange(self.energies[i].shape[0]):
                if j == 0:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.fluxes[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                        label=label,
                    )
                else:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.fluxes[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                    )

        _plt.yscale(yscale)
        _plt.xscale(xscale)

        if xlim:
            _plt.xlim(xlim[0], xlim[1])
        if ylim:
            _plt.ylim(ylim[0], ylim[1])

        _plt.xlabel("Energy [keV]")
        _plt.ylabel("Flux [ph/s/0.1%/100mA]")
        _plt.title(title)

        _plt.minorticks_on()
        _plt.tick_params(
            which="both", axis="both", direction="in", top=True, right=True
        )
        _plt.grid(which="major", alpha=0.4)
        _plt.grid(which="minor", alpha=0.2)

        _plt.legend(fontsize=legend_fs)
        _plt.tight_layout()

        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_flux_density_matrix(
        self,
        title=None,
        clim=(None, None),
        cscale="linear",
        savefig=False,
        figsize=(5, 4),
        figname="flux_density_matrix.png",
        dpi=400,
    ):
        """Plot Flux Density Matrix (period x length).

        Args:
            title (str, optional): Plot title.
            cscale (str, optional): color bar scale
             cscale. Defalts to 'linear'.
            clim (tuple): color bar limits.
             Defaults to (None, None) will take the minimum or/and maximum limit
            savefig (bool, optional): Save Figure
             savefig. Defalts to False.
            figname (str, optional): Figure name
             figname. Defalts to 'flux_density_matrix.png'
            dpi (int, optional): Image resolution
             dpi. Defalts to 400.
            figsize (tuple, optional): Figure size.
             figsize. Defalts to (5, 4)
        """
        # Getting the parameters of the best undulator
        info = self._info_matrix_flux_density[
            _np.argmax(self._flux_density_matrix.ravel())
        ]

        period_number = info[1]
        length_number = info[2]

        # Getting the position of the best flux density
        j = int(
            _np.argmax(self._flux_density_matrix.ravel())
            / len(self._flux_density_matrix[0, :])
        )
        i = _np.argmax(self._flux_density_matrix.ravel()) % len(
            self._flux_density_matrix[0, :]
        )

        # Label creation
        label = "Target Energy: {:.2f} KeV\n".format(self._target_energy / 1e3)
        label += "Best undulator: ({:.2f} mm, {:.2f} m)\n".format(
            period_number, length_number
        )
        label += "Flux density: {:.2e} ph/s/mrad²/0.1%/100mA".format(
            self._flux_density_matrix[j, i]
        )

        fig, ax = _plt.subplots(figsize=figsize)
        ax.set_title(label if title == None else title)
        ax.set_ylabel("Length [m]")
        ax.set_xlabel("Period [mm]")

        vmin = clim[0]
        vmax = clim[1]

        if vmin is None:
            vmin = _np.min(self._flux_density_matrix)
        if vmax is None:
            vmax = _np.max(self._flux_density_matrix)

        step = (
            5
            if cscale == "linear"
            else int(_np.log10(vmax) - _np.log10(vmin) + 1)
        )
        vmin = vmin if cscale == "linear" else _np.log10(vmin)
        vmax = vmax if cscale == "linear" else _np.log10(vmax)
        fm = (
            self._flux_density_matrix
            if cscale == "linear"
            else _np.log10(self._flux_density_matrix)
        )

        ax.imshow(
            fm,
            extent=[
                self._info_matrix_flux_density[0, 1],
                self._info_matrix_flux_density[-1, 1],
                self._info_matrix_flux_density[0, 2],
                self._info_matrix_flux_density[-1, 2],
            ],
            aspect="auto",
            origin="lower",
            norm=colors.Normalize(vmin=vmin, vmax=vmax)
            if cscale == "linear"
            else colors.LogNorm(vmin=vmin, vmax=vmax),
        )
        sm = _plt.cm.ScalarMappable(_plt.Normalize(vmin=vmin, vmax=vmax))
        sm.set_array(fm)
        cbar = fig.colorbar(
            sm,
            ax=ax,
            label="Flux density [ph/s/mrad²/0.1%/100mA]",
            format="%.1e" if cscale == "linear" else "%.0i",
        )
        cbar.set_ticks(_np.linspace(vmin, vmax, step))
        fig.tight_layout()
        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_flux_matrix(
        self,
        title=None,
        clim=(None, None),
        cscale="linear",
        cmap='viridis',
        savefig=False,
        figsize=(5, 4),
        figname="flux_matrix.png",
        dpi=400,
    ):
        """Plot Flux Matrix (period x length).

        Args:
            title (str, optional): Plot title.
            cscale (str, optional): color bar scale
             cscale. Defalts to 'linear'.
            clim (tuple): color bar limits.
             Defaults to (None, None) will take the minimum or/and maximum limit
            cmap (str): colormap.
            savefig (bool, optional): Save Figure
             savefig. Defalts to False.
            figname (str, optional): Figure name
             figname. Defalts to 'flux_matrix.png'
            dpi (int, optional): Image resolution
             dpi. Defalts to 400.
            figsize (tuple, optional): Figure size.
             figsize. Defalts to (5, 4)
        """
        # Getting the parameters of the best undulator
        info = self._info_matrix_flux[_np.argmax(self._flux_matrix.ravel())]

        period_number = info[1]
        length_number = info[2]

        # Getting the position of the best brilliance
        j = int(
            _np.argmax(self._flux_matrix.ravel())
            / len(self._flux_matrix[0, :])
        )
        i = _np.argmax(self._flux_matrix.ravel()) % len(
            self._flux_matrix[0, :]
        )

        # Label creation
        label = "Target Energy: {:.2f} KeV\n".format(self._target_energy / 1e3)
        label += "Best undulator: ({:.2f} mm, {:.2f} m)\n".format(
            period_number, length_number
        )
        label += "Flux: {:.2e} ph/s/0.1%/100mA".format(self._flux_matrix[j, i])

        fig, ax = _plt.subplots(figsize=figsize)
        ax.set_title(label if title == None else title)
        ax.set_ylabel("Length [m]")
        ax.set_xlabel("Period [mm]")

        vmin = clim[0]
        vmax = clim[1]

        if vmin is None:
            vmin = _np.min(self._flux_matrix)
        if vmax is None:
            vmax = _np.max(self._flux_matrix)

        step = (
            5
            if cscale == "linear"
            else int(_np.log10(vmax) - _np.log10(vmin) + 1)
        )
        vmin = vmin if cscale == "linear" else _np.log10(vmin)
        vmax = vmax if cscale == "linear" else _np.log10(vmax)
        fm = (
            self._flux_matrix
            if cscale == "linear"
            else _np.log10(self._flux_matrix)
        )

        ax.imshow(
            fm,
            extent=[
                self._info_matrix_flux[0, 1],
                self._info_matrix_flux[-1, 1],
                self._info_matrix_flux[0, 2],
                self._info_matrix_flux[-1, 2],
            ],
            aspect="auto",
            origin="lower",
            cmap=cmap,
            norm=colors.Normalize(vmin=vmin, vmax=vmax)
            if cscale == "linear"
            else colors.LogNorm(vmin=vmin, vmax=vmax),
        )
        sm = _plt.cm.ScalarMappable(_plt.Normalize(vmin=vmin, vmax=vmax), cmap=cmap)
        sm.set_array(fm)
        cbar = fig.colorbar(
            sm,
            ax=ax,
            label="Flux [ph/s/0.1%/100mA]",
            format="%.1e" if cscale == "linear" else "%.0i",
            cmap=cmap,
        )
        cbar.set_ticks(_np.linspace(vmin, vmax, step))
        fig.tight_layout()
        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_brilliance_matrix(
        self,
        title=None,
        clim=(None, None),
        cscale="linear",
        savefig=False,
        figsize=(5, 4),
        figname="brilliance_matrix.png",
        dpi=400,
    ):
        """Plot Brilliance Matrix (period x length).

        Args:
            title (str, optional): Plot title.
            cscale (str, optional): color bar scale
             cscale. Defalts to 'linear'.
            clim (tuple): color bar limits.
             Defaults to (None, None) will take the minimum or/and maximum limit
            savefig (bool, optional): Save Figure
             savefig. Defalts to False.
            figname (str, optional): Figure name
             figname. Defalts to 'brilliance_matrix.png'
            dpi (int, optional): Image resolution
             dpi. Defalts to 400.
            figsize (tuple, optional): Figure size.
             figsize. Defalts to (5, 4)
        """
        # Getting the parameters of the best undulator
        info = self._info_matrix_brilliance[
            _np.argmax(self._brilliance_matrix.ravel())
        ]

        period_number = info[1]
        length_number = info[2]

        # Getting the position of the best brilliance
        j = int(
            _np.argmax(self._brilliance_matrix.ravel())
            / len(self._brilliance_matrix[0, :])
        )
        i = _np.argmax(self._brilliance_matrix.ravel()) % len(
            self._brilliance_matrix[0, :]
        )

        # Label creation
        label = "Target Energy: {:.2f} KeV\n".format(self._target_energy / 1e3)
        label += "Best undulator: ({:.2f} mm, {:.2f} m)\n".format(
            period_number, length_number
        )
        label += "Brilliance: {:.2e} ph/s/0.1%/mm²/mrad²/100mA".format(
            self._brilliance_matrix[j, i]
        )

        fig, ax = _plt.subplots(figsize=figsize)
        ax.set_title(label if title is None else title)
        ax.set_ylabel("Length [m]")
        ax.set_xlabel("Period [mm]")

        vmin = clim[0]
        vmax = clim[1]

        if vmin is None:
            vmin = _np.min(self._brilliance_matrix)
        if vmax is None:
            vmax = _np.max(self._brilliance_matrix)

        step = (
            5
            if cscale == "linear"
            else int(_np.log10(vmax) - _np.log10(vmin) + 1)
        )
        vmin = vmin if cscale == "linear" else _np.log10(vmin)
        vmax = vmax if cscale == "linear" else _np.log10(vmax)
        bm = (
            self._brilliance_matrix
            if cscale == "linear"
            else _np.log10(self._brilliance_matrix)
        )

        ax.imshow(
            bm,
            extent=[
                self._info_matrix_brilliance[0, 1],
                self._info_matrix_brilliance[-1, 1],
                self._info_matrix_brilliance[0, 2],
                self._info_matrix_brilliance[-1, 2],
            ],
            aspect="auto",
            origin="lower",
            norm=colors.Normalize(vmin=vmin, vmax=vmax)
            if cscale == "linear"
            else colors.LogNorm(vmin=vmin, vmax=vmax),
        )
        sm = _plt.cm.ScalarMappable(_plt.Normalize(vmin=vmin, vmax=vmax))
        sm.set_array(bm)
        cbar = fig.colorbar(
            sm,
            ax=ax,
            label="Brilliance [ph/s/0.1%/mm²/mrad²/100mA]",
            format="%.1e" if cscale == "linear" else "%.0i",
        )
        cbar.set_ticks(_np.linspace(vmin, vmax, step))
        fig.tight_layout()
        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_total_power_matrix(
        self,
        data: tuple,
        title: str = "Total Power of Undulators",
        clim: tuple = (None, None),
        cscale: str = "linear",
        savefig: bool = False,
        figsize: tuple = (5, 4),
        figname: str = "total_power_matrix.png",
        dpi: int = 400,
    ):
        """Plot Total Power Matrix (period x length).

        Args:
            title (str, optional): Plot title.
            cscale (str, optional): color bar scale
             cscale. Defalts to 'linear'.
            clim (tuple): color bar limits.
             Defaults to (None, None) will take the minimum or/and maximum limit
            savefig (bool, optional): Save Figure
             savefig. Defalts to False.
            figsize (tuple, optional): Figure size.
             figsize. Defalts to (5, 4)
            figname (str, optional): Figure name
             figname. Defalts to 'total_power_matrix.png'
            dpi (int, optional): Image resolution
             dpi. Defalts to 400.
            data (tuple): data especified
             First position 'flux matrix' or 'flux density matrix' or 'brilliance matrix'
             Second position unds matrix
        """
        if data is None:
            raise ValueError("'unds_matrix' parameter has to be defined")

        vmin = clim[0]
        vmax = clim[1]

        info_unds_matrix = data[1]

        current = 100
        ks = info_unds_matrix[:, 0]
        periods = info_unds_matrix[:, 1]
        lengths = info_unds_matrix[:, 2]

        # Calc Fields
        bs = (ks * EMASS * LSPEED * 2 * PI) / (ECHARGE * periods * 1e-3)

        # Calc total power
        const = ((ECHARGE**4) * (self.accelerator.gamma**2)) / (
            12 * PI * VACUUM_PERMITTICITY * (EMASS**2) * (LSPEED**2)
        )
        total_powers = (
            const * (bs**2) * lengths * (current * 1e-3) / (1e3 * ECHARGE)
        )

        pts_period = len(
            _np.where(info_unds_matrix[:, 2] == info_unds_matrix[0, 2])[0]
        )
        pts_length = len(
            _np.where(info_unds_matrix[:, 1] == info_unds_matrix[0, 1])[0]
        )

        total_powers = total_powers.reshape(pts_length, pts_period)

        if vmin is None:
            vmin = _np.min(total_powers)
        if vmax is None:
            vmax = _np.max(total_powers)

        fig, ax = _plt.subplots(figsize=(figsize))
        ax.set_title(title)
        ax.set_ylabel("Length [m]")
        ax.set_xlabel("Period [mm]")

        step = (
            5
            if cscale == "linear"
            else int(_np.log10(vmax) - _np.log10(vmin) + 1)
        )
        vmin = vmin if cscale == "linear" else _np.log10(vmin)
        vmax = vmax if cscale == "linear" else _np.log10(vmax)
        pm = total_powers if cscale == "linear" else _np.log10(total_powers)

        ax.imshow(
            pm,
            extent=[
                _np.min(periods),
                _np.max(periods),
                _np.min(lengths),
                _np.max(lengths),
            ],
            aspect="auto",
            origin="lower",
            norm=colors.Normalize(vmin=vmin, vmax=vmax)
            if cscale == "linear"
            else colors.LogNorm(vmin=vmin, vmax=vmax),
        )

        sm = _plt.cm.ScalarMappable(_plt.Normalize(vmin=vmin, vmax=vmax))
        sm.set_array(pm)

        cbar = fig.colorbar(
            sm,
            ax=ax,
            label="Total Power [kW]",
            format="%.2f" if cscale == "linear" else "%.0i",
        )
        cbar.set_ticks(_np.linspace(vmin, vmax, step))
        fig.tight_layout()
        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_partial_power_matrix(
        self,
        title: str = "Partial Power of Undulators",
        clim: tuple = (None, None),
        cscale: str = "linear",
        savefig: bool = False,
        figsize: tuple = (5, 4),
        figname: str = "partial_power_matrix.png",
        dpi: int = 400,
        partial_power_matrix=None,
    ):
        """Plot Partial Power Matrix (period x length).

        Args:
            title (str, optional): Plot title.
            cscale (str, optional): color bar scale
             cscale. Defalts to 'linear'.
            clim (tuple): color bar limits.
             Defaults to (None, None) will take the minimum or/and maximum limit
            savefig (bool, optional): Save Figure
             savefig. Defalts to False.
            figsize (tuple, optional): Figure size.
             figsize. Defalts to (5, 4)
            figname (str, optional): Figure name
             figname. Defalts to 'partial_power_matrix.png'
            dpi (int, optional): Image resolution
             dpi. Defalts to 400.
            partial_power_matrix (numpy array): partial power matrix of undulators information to use in calculation
        """
        if partial_power_matrix is None:
            raise ValueError(
                "'partial_power_matrix' parameter has to be defined"
            )

        if self._info_matrix_flux is not None:
            info_unds_matrix = self._info_matrix_flux
        elif self._info_matrix_flux_density is not None:
            info_unds_matrix = self._info_matrix_flux_density
        elif self._info_matrix_brilliance is not None:
            info_unds_matrix = self._info_matrix_brilliance

        periods = info_unds_matrix[:, 1]
        lengths = info_unds_matrix[:, 2]

        vmin = clim[0]
        vmax = clim[1]

        if vmin is None:
            vmin = _np.min(partial_power_matrix)
        if vmax is None:
            vmax = _np.max(partial_power_matrix)

        fig, ax = _plt.subplots(figsize=(figsize))
        ax.set_title(title)
        ax.set_ylabel("Length [m]")
        ax.set_xlabel("Period [mm]")

        step = (
            5
            if cscale == "linear"
            else int(_np.log10(vmax) - _np.log10(vmin) + 1)
        )
        vmin = vmin if cscale == "linear" else _np.log10(vmin)
        vmax = vmax if cscale == "linear" else _np.log10(vmax)
        partial_power_matrix = (
            partial_power_matrix
            if cscale == "linear"
            else _np.log10(partial_power_matrix)
        )

        ax.imshow(
            partial_power_matrix,
            extent=[
                _np.min(periods),
                _np.max(periods),
                _np.min(lengths),
                _np.max(lengths),
            ],
            aspect="auto",
            origin="lower",
            norm=colors.Normalize(vmin=vmin, vmax=vmax)
            if cscale == "linear"
            else colors.LogNorm(vmin=vmin, vmax=vmax),
        )

        sm = _plt.cm.ScalarMappable(_plt.Normalize(vmin=vmin, vmax=vmax))
        sm.set_array(partial_power_matrix)

        cbar = fig.colorbar(
            sm,
            ax=ax,
            label="Partial Power [kW]",
            format="%.3f" if cscale == "linear" else "%.0i",
        )
        cbar.set_ticks(_np.linspace(vmin, vmax, step))
        fig.tight_layout()
        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def get_undulator_from_matrix(
        self, target_period: float, target_length: float, data: tuple
    ):
        """Get information about the target point in matrix.

        Args:
            target_period (float): Undulator period [mm]
            target_length (float): Undulator length [m]
            data (tuple): data especified to use in calculation
                First position 'flux matrix' or 'flux density matrix' or 'brilliance matrix'
                Second position unds matrix
        """  # noqa: E501, D202

        if data is None:
            raise ValueError("'data' parameter has to be defined")

        result_matrix = data[0]
        info_unds_matrix = data[1]

        pts_period = len(result_matrix[0, :])
        pts_length = len(result_matrix[:, 0])

        max_period = _np.max(info_unds_matrix[:, 1])
        min_period = _np.min(info_unds_matrix[:, 1])

        max_length = _np.max(info_unds_matrix[:, 2])
        min_length = _np.min(info_unds_matrix[:, 2])

        rtol_length = 0.6 * (max_length - min_length) / pts_length
        rtol_period = 0.6 * (max_period - min_period) / pts_period

        idcs_period = _np.isclose(
            info_unds_matrix[:, 1], target_period, atol=rtol_period
        )
        idcs_p = _np.where(idcs_period)[0]

        idcs_length = _np.isclose(
            info_unds_matrix[idcs_p, 2], target_length, atol=rtol_length
        )
        idcs_l = _np.where(idcs_length)[0]

        idxs = idcs_p[idcs_l]

        print(
            "{:}{:<2}{:}{:<5}{:}{:<7}{:}{:<7}{:}{:<3}{:}{:<2}{:}{:<2}{:}{:<2}{:}".format(
                "Und",
                "",
                "Keff",
                "",
                "Ky",
                "",
                "Kx",
                "",
                "Gap",
                "",
                "Period",
                "",
                "Length",
                "",
                "H Number",
                "",
                "Result",
            )
        )

        for i, idx in enumerate(idxs):
            print(
                "{:}{:<4}{:.5f}{:<2}{:.5f}{:<2}{:.5f}{:<2}{:.2f}{:<2}{:.2f}{:<3}{:.2f}{:<4}{:}{:<9}{:.2e}".format(
                    i,
                    "",
                    info_unds_matrix[idx][0],
                    "",
                    info_unds_matrix[idx][5],
                    "",
                    info_unds_matrix[idx][6],
                    "",
                    info_unds_matrix[idx][4],
                    "",
                    info_unds_matrix[idx][1],
                    "",
                    info_unds_matrix[idx][2],
                    "",
                    int(info_unds_matrix[idx][3]),
                    "",
                    result_matrix.ravel()[idx],
                )
            )
